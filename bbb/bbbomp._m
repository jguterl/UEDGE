c!include "bbb.h"
c!include "../com/com.h"
c!include "../mppl.h"
c!include "../sptodp.h"
        subroutine InitOMP()
        Use(OmpJacobian)
        Use(OmpOptions)
        Use(Jacobian)
        Use(Lsode)
        integer:: OMP_GET_NUM_THREADS,OMP_GET_THREAD_NUM
cJG do the allocation for omp variables
c!ifdef _OPENMP
      If (ParallelJac.eq.1) then
       write(iout*,'(a,i3)') '**** OMP actived'
c$omp parallel
      if (OMP_GET_THREAD_NUM().eq.0) then
      if (Nthreads.gt.OMP_GET_NUM_THREADS()) then
            write(iout*,*) '**** Warning: Number of threads requested is larger the maximum number of threads available.
     . Nthreadsmax:',OMP_GET_NUM_THREADS()
            write(iout*,*) '**** Resetting Nthreads to Nthreadsmax'
            Nthreads=OMP_GET_NUM_THREADS()
      endif
      if (Nthreads.le.0) then
      call xerrab('Nthread must be >0')
      endif
      if (OMPVerbose.gt.0) write(iout*,'(a,i3)') '**** Number of threads for omp calculations:',Nthreads
      endif
c$omp END parallel
c!else
       Nthreads=1
        write(iout*,'(a,i3)') '**** OMP not actived'
c!endif



      if (Nthreads.gt.1) then
      nnzmxperthread=ceiling(real(nnzmx)/real(Nthreads-1))*omplenpfac
      else
      nnzmxperthread=nnzmx*omplenpfac
      endif
      ompneq=neq
       call gchange('OmpJacobian',0)
      else
       write(iout*,'(a,i3)') '**** OMP not actived'
      endif

        end subroutine InitOMP

      subroutine jac_calc_para (neq, t, yl, yldot00, ml, mu, wk,
     .                     nnzmx, jac, ja, ia)

c ... Calculate Jacobian matrix (derivatives with respect to each
c     dependent variable of the right-hand side of each rate equation).
c     Lower and upper bandwidths are used to select for computation
c     only those Jacobian elements that may be nonzero.
c     Estimates of Jacobian elements are computed by finite differences.
c     The Jacobian is stored in compressed sparse row format.

      implicit none

c ... Input arguments:
      integer,intent(in):: neq      # total number of equations (all grid points)
      real,intent(in):: t           # physical time
      real,intent(in):: yl(*)       # dependent variables
      real,intent(in):: yldot00(neq+2) # right-hand sides evaluated at yl
      integer,intent(in):: ml, mu   # lower and upper bandwidths
      integer,intent(in):: nnzmx    # maximum number of nonzeros in Jacobian
c ... Output arguments:
      real,intent(out):: jac(nnzmx)     # nonzero Jacobian elements
      integer,intent(out):: ja(nnzmx)   # col indices of nonzero Jacobian elements
      integer,intent(out):: ia(neq+1)   # pointers to beginning of each row in jac,ja

c ... Work-array argument:
      real wk(neq)     # work space available to this subroutine
      integer,allocatable :: iJacConstructor(:,:)
      real,allocatable:: rJacConstructor(:,:)

c ... Common blocks:
      Use(Dim)                     # nx,ny,
                                   # nusp[for fnorm not used here]
      Use(Timing)                  # istimingon,ttjstor,ttotjf,ttimpjf
      Use(Math_problem_size)       # neqmx,numvar
      Use(Grid)                    # ngrid,ig,ijac,ijactot
      Use(Indexes)                 # igyl,iseqalg
      Use(Variable_perturbation)   # del,dylconst
      Use(Jacobian_csc)            # rcsc,jcsc,icsc,yldot_pert
      Use(Ynorm)                   # suscal,sfscal
      Use(UEpar)                   # isphion,isnewpot,svrpkg,isbcwdt
      Use(Model_choice)            # iondenseqn
      Use(Imprad)                  # isimpon
      Use(Bcond)                   # isextrnpf,isextrtpf,isextrngc,
                                   # isextrnw,isextrtw
      Use(Parallv)                 # nxg,nyg
      Use(Time_dep_nwt)            # nufak,dtreal,ylodt,dtuse
      Use(Selec)                   # yinc
      Use(Preconditioning)         #lenpfac
      Use(OmpOptions)
      Use(OmpJacobian)
c ... Functions
      logical tstguardc
      real(Size4) gettime
cc      real(Size4) ranf

c ... Local variables:
      integer i,thread
      integer,allocatable::nnz(:),nnzcum(:)
*      integer,allocatable,dimension(:,:) ::iJacCol,iJacRow
*      real,allocatable,dimension(:,:) ::rJacElem
      real(Size4) sec4, tsjstor, tsimpjf, dtimpjf,time0,time1,TimeBuild
      real(Size4) TimeReduce
      INTEGER ::  TID, OMP_GET_THREAD_NUM
      integer:: ith,iv
      character(len = 80) ::  filename


cJG Get the range of the iv index for each thread
       call SplitIndex(neq,Nthreads,ivmin,ivmax)

       if (OMPDebug.gt.0) then
        write(iout*,*)' **** Ivmin(ithread),Ivmax(ithread) ***'
            do ith=1,Nthreads
                write(iout*,*) 'ithread ', ith,':',ivmin(ith),ivmax(ith)
            enddo
        endif


*      allocate(iJacRow(neq,Nthreads))
*      allocate(iJacCol(nnzmxperthread,Nthreads))
*      allocate(rJacElem(nnzmxperthread,Nthreads))
      allocate(nnz(Nthreads))
      allocate(nnzcum(Nthreads))
      nnz(1:Nthreads)=-1
      nnzcum(1:Nthreads)=-1
      write(iout*,*) 'Allocatation done....'
      iJacCol(1:nnzmxperthread,1:Nthreads)=0
      write(iout*,*) 'Inialization iJacCol done....'
      rJacElem(1:nnzmxperthread,1:Nthreads)=0.0
      write(iout*,*) 'Inialization rJacElem done....'
      iJacRow(1:neq,1:Nthreads)=0
      write(iout*,*) 'Inialization iJacRow done....'



c ... Get initial value of system cpu timer.
      if (istimingon .eq. 1) tsjstor = gettime(sec4)

c ... Pause from BASIS if a ctrl_c is typed
      call ruthere

c ... Count Jacobian evaluations, both for total and for this case
      ijactot = ijactot + 1
      ijac(ig) = ijac(ig) + 1
      if (svrpkg.eq.'nksol') write(iout*,*) ' Updating Jacobian, npe =  ',
     .                                                          ijac(ig)

c ... Set up diagnostic arrays for debugging
      do iv = 1, neq
        yldot_unpt(iv) = yldot00(iv)  # for diagnostic only
        yldot_pert(iv) = 0.
      enddo

c############################################
c ... Begin loop over dependent variables.
c############################################
cJG Running with  openmp target requires to have -fopen flag and foffload flag added to both gfortran and gcc.
c JG Let test it with a gpu (maybe summit 1 at GA?)

      TimeBuild=gettime(sec4)
        call OMPJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml, mu,wk,
     .                      iJacCol,rJacElem,iJacRow,nnz,nnzmxperthread,
     .                      nthreads)

c##############################################################
      TimeBuild=gettime(sec4)-TimeBuild
      if (OMPVerbose.gt.0) write(iout*,*)'Time to build jac:',TimeBuild
      if (DebugTime.gt.0) then
      write(iout*,*)'Time in var loop calc_jac:',gettime(sec4)-tsjstor
      endif

c #reduction of jacobian data into single vector
      TimeReduce=gettime(sec4)
      nnzcum(1)=nnz(1)-1
      do ith=2,Nthreads
        nnzcum(ith)=nnzcum(ith-1)+nnz(ith)-1
      enddo
      if (OMPVerbose.gt.0) write(iout*,'(a,i9)') '**** Number of non-zero Jacobian elems:',nnzcum(Nthreads)
      if (nnzcum(Nthreads).gt.nnzmx) then
        call xerrab(' Problem: nnzcum > nnzmx...')
      endif


        jcsc(ivmin(1):ivmax(1))= iJacRow(ivmin(1):ivmax(1),1)
      do ith=2,Nthreads
        jcsc(ivmin(ith):ivmax(ith))= iJacRow(ivmin(ith):ivmax(ith),ith)
     .                                +nnzcum(ith-1)
      enddo

      rcsc(1:nnz(1)-1)= rJacElem(1:nnz(1)-1,1)
      icsc(1:nnz(1)-1)= iJacCol(1:nnz(1)-1,1)
      do ith=2,Nthreads
       rcsc(nnzcum(ith-1)+1:nnzcum(ith))=
     .                            rJacElem(1:nnz(ith)-1,ith)
       icsc(nnzcum(ith-1)+1:nnzcum(ith))=
     .                            iJacCol(1:nnz(ith)-1,ith)
      enddo






      jcsc(neq+1) = nnzcum(Nthreads)+1


      TimeReduce=gettime(sec4)-TimeReduce
      write(iout*,*)'**** Time to reduce jac:',TimeReduce
c      deallocate(iJacRow)
c      deallocate(iJacCol)
c      deallocate(rJacElem)
      deallocate(nnz)
      deallocate(nnzcum)
c ... Convert Jacobian from compressed sparse column to compressed
c     sparse row format.
      time1=gettime(sec4)
cJG for Debug purpose
       if (WriteJacobian.eq.1) then
       write(ioutfilename,'(a,3i3,a)') "jac_omp_",ijac(ig),".txt"
       call jac_write(ioutfilename,neq, rcsc, icsc, jcsc)
       endif
      do i=1,nnzmx
      if (isnan(rcsc(i))) then
      write(iout*,*) 'rcsc is NaN at i=',i,rcsc(i)
      endif
      if (icsc(i).ne.icsc(i)) then
      write(iout*,*) 'icsc is NaN at i=',i,icsc(i)
      endif
      enddo
      do i=1,neq+1
      if (jcsc(i).ne.jcsc(i)) then
      write(iout*,*) 'jcsc is NaN at i=',i
      endif
      enddo
      call csrcsc (neq, 1, 1, rcsc, icsc, jcsc, jac, ja, ia)

      if (DebugTime.gt.0) then
      write(iout*,*)'Time to convert jac:',gettime(sec4)-time1
      endif


cccc ... If desired, calculate Jacobian elements for ion continuity
cccc     equation by using INEL routines, and combine elements with
cccc     those calculated above.
ccc      if (iondenseqn .eq. "inel") then
ccc         call iondens2 (neq, nnzmx, jac, ja, ia, rcsc, icsc, jcsc)
ccc      endif

cccc ... If necessary, calculate Jacobian elements for rows corresponding
cccc     to impurity-density equations (for cells other than guard cells),
cccc     and combine elements with those calculated above.
ccc      if (isimpon .eq. 3 .or. isimpon .eq. 4) then
ccc         if (istimingon .eq. 1) tsimpjf = gettime(sec4)
ccc         call impdens2 (neq, nnzmx, jac, ja, ia, rcsc, icsc, jcsc)
ccc         if (istimingon .eq. 1) then
ccc            dtimpjf = gettime(sec4) - tsimpjf
ccc            ttimpjf = ttimpjf + dtimpjf
ccc            ttotjf = ttotjf + dtimpjf
ccc         endif
ccc      endif

      if (istimingon .eq. 1) ttjstor = ttjstor + gettime(sec4) - tsjstor
      if (DebugTime.gt.0) then
      write(iout*,*)'Time in calc_jac:',gettime(sec4)-tsjstor
      endif


      return
      end subroutine jac_calc_para
c-----------------------------------------------------------------------
        subroutine SplitIndex(neq,Nthreads,ivmin,ivmax)
        integer,intent(in)::neq,Nthreads
        integer,intent(out)::ivmin(Nthreads),ivmax(Nthreads)
        integer:: Nsize,R,i

       Nsize=neq/Nthreads
       R=MOD(neq, Nthreads)
       if (Nthreads.gt.1) then
            if (R.eq.0) then
                do i=1,Nthreads
                    ivmin(i)=1+Nsize*(i-1)
                    ivmax(i)=Nsize*i
                enddo
            else
                do i=1,Nthreads-1
                ivmin(i)=1+Nsize*(i-1)
                ivmax(i)=Nsize*i
                enddo
                ivmin(Nthreads)=ivmax(Nthreads-1)+1
                ivmax(Nthreads)=neq
            endif
        else
            ivmin(Nthreads)=1
            ivmax(Nthreads)=neq
        endif
        end subroutine SplitIndex


c-----------------------------------------------------------------------
      subroutine OMPJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml,
     .  mu,wk,iJacCol,rJacElem,iJacRow,nnz,nnzmx,
     .                      nthreads)
        implicit none
        Use(OmpOptions)
        Use(OmpCopybbb)
        Use(OmpCopycom)
        Use(OmpCopyapi)

        Use(Compla)
        Use(Dim)
        Use(Selec)
        Use(Math_problem_size)
        Use(MCN_dim)
        Use(Indices_domain_dcl)
        Use(Reduced_ion_interface)
        Use(Coefeq)
          integer,intent(in):: nnzmx,nthreads
          integer,intent(inout)::nnz(Nthreads)
          integer,intent(in):: ivmin(Nthreads),ivmax(Nthreads)      # index equation
          integer,intent(in):: neq      # total number of equations (all grid points)
          integer,intent(in):: ml, mu   # lower and upper bandwidths
          real,intent(in):: t           # physical time
          real,intent(in) ::yl(*)       # dependent variables
          real,intent(in) ::yldot00(neq+2) # right-hand sides evaluated at yl
          real,intent(inout) :: wk(neq)
          integer,intent(out)::iJacCol(nnzmxperthread,nthreads)
          integer,intent(out):: iJacRow(neq,nthreads)
          real,intent(out):: rJacElem(nnzmxperthread,nthreads)
          real ::wkcopy(neq)
          real::ylcopy(neq+2)

       integer ::iJacColCopy(nnzmx),iJacRowCopy(neq)
       integer ::ivmincopy(Nthreads),ivmaxcopy(Nthreads)
       integer ::Nthreadscopy
          real :: rJacElemCopy(nnzmx)
        integer:: ith,omp_get_thread_num,tid,nnzlocal,ithcopy


      if (OMPDebug.gt.0) then
      write(iout*,*) '**** Copying data....'
      endif
      if (OMPCopyArray.gt.0) then
      call OmpCopyPointerbbb
      call OmpCopyPointercom
      call OmpCopyPointerapi
      endif
      if (OMPCopyScalar.gt.0) then
      call OmpCopyScalarbbb
      call OmpCopyScalarcom
      call OmpCopyScalarapi
      endif
cJG We cannot use variables in the parallel construct declarations below
cJG when these variables are not in the scope of the subroutine
      Nthreadscopy=Nthreads
      ivmincopy(1:Nthreads)=ivmin(1:Nthreads)
      ivmaxcopy(1:Nthreads)=ivmax(1:Nthreads)
      iJacColCopy(1:nnzmx)=0
      rJacElemCopy(1:nnzmx)=0.0
      iJacRowCopy(1:neq)=0
      ylcopy(1:neq+2)=yl(1:neq+2) # a very barbarian use of yl(neq+1) is implemented as a switch in pandf... Error-prone!
      wkcopy(1:neq)=wk(1:neq)

      if (OMPDebug.gt.0) then
      write(iout*,*) '**** Starting parallel loop'
      endif
      tid=-1
       nnzlocal=-10000

c$omp parallel do default(shared)
c$omp& firstprivate(ithcopy,ivmincopy,ivmaxcopy,tid,nnzlocal,ylcopy,wkcopy,ml,mu,yldot00,t,neq)
c$omp& firstprivate(nnzmx,nthreadscopy)
c$omp& firstprivate(iJacRowCopy)
c$omp& firstprivate(iJacColCopy)
c$omp& firstprivate(rJacElemCopy)
cccc$omp& shared(nnz,iJacCol,rJacElem,iJacRow)
        do ith=1,Nthreads !ith from 1 to Nthread, tid from 0 to Nthread-1
        tid=omp_get_thread_num()
        ithcopy=ith
        if (OMPDebug.gt.0) write(iout*,*) '#OMP: Thread id:',tid,' <-> ith:',ithcopy

      call LocalJacBuilder(ivmin(ithcopy),ivmax(ithcopy),neq, t, ylcopy,yldot00,
     . ml,mu,wkcopy,iJacColcopy,rJacElemcopy,iJacRowcopy,ithcopy,nnzlocal,
     . nnzmx,nthreads)
      if (OMPDebug.gt.0) write(iout*,*) '#,',tid,' nzlocal:',nnzlocal
c$omp critical
      iJacCol(1:nnzlocal,ithcopy)=iJacColCopy(1:nnzlocal)
      rJacElem(1:nnzlocal,ithcopy)=rJacElemCopy(1:nnzlocal)
      iJacRow(1:neq,ithcopy)=iJacRowCopy(1:neq)
      nnz(ithcopy)=nnzlocal
c$omp end critical

c##############################################################
c      enddo             # end of main loop over yl variables
      enddo
c$omp END PARALLEL DO

      if (OMPDebug.gt.0) then
      write(iout*,*) '**** End of parallel loop....'
      endif



      end subroutine OMPJacBuilder

c ----------------------------------------------------------------------
      subroutine LocalJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml, mu, wk,
     .                      iJacCol,rJacElem,iJacRow,ith,nnz,nnzmx,
     .                      nthreads)


c ... Calculate Jacobian matrix (derivatives with respect to each
c     dependent variable of the right-hand side of each rate equation).
c     Lower and upper bandwidths are used to select for computation
c     only those Jacobian elements that may be nonzero.
c     Estimates of Jacobian elements are computed by finite differences.
c     The Jacobian is stored in compressed sparse row format.

      implicit none

      integer,intent(in):: ith,nnzmx,nthreads
      integer,intent(inout)::nnz
      integer,intent(in):: ivmin,ivmax      # index equation
      integer,intent(in):: neq      # total number of equations (all grid points)
      real,intent(in):: t           # physical time
      real ::yl(*)       # dependent variables
      integer,intent(inout)::iJacCol(nnzmx),iJacRow(neq)
      real,intent(inout):: rJacElem(nnzmx)
      real,intent(in) ::yldot00(neq+2) # right-hand sides evaluated at yl
      integer,intent(in):: ml, mu   # lower and upper bandwidths

c ... Work-array argument:
      real,intent(inout) :: wk(neq)     # work space available to this subroutine
c ... Common blocks:
      Use(Dim)                     # nx,ny
      Use(Timing)                  # istimingon,ttjstor,ttotjf,ttimpjf
      Use(Math_problem_size)       # neqmx,numvar
      Use(Grid)                    # ngrid,ig,ijac,ijactot
      Use(Indexes)                 # igyl,iseqalg
      Use(Variable_perturbation)   # del,dylconst
      Use(Jacobian_clipping)       # jaccliplim,istopjac,irstop,icstop
      Use(Ynorm)                   # suscal,sfscal
      Use(UEpar)                   # isphion,isnewpot,svrpkg,isbcwdt
      Use(Model_choice)            # iondenseqn
      Use(Imprad)                  # isimpon
      Use(Bcond)                   # isextrnpf,isextrtpf,isextrngc,
                                   # isextrnw,isextrtw
      Use(Parallv)                 # nxg,nyg
      Use(Time_dep_nwt)            # nufak,dtreal,ylodt,dtuse
      Use(Selec)                   # yinc
      Use(Preconditioning)         #lenpfac
      Use(Jacobian_csc)
      Use(OmpOptions)
      Use(Compla)
c ... Functions:
      logical ::tstguardc
      real(Size4) gettime
cc      real(Size4) ranf

c ... Local variables:
      integer :: ii, iv, jv,ii1, ii2, xc, yc, ix, iy

      real ::yold, dyl, jacelem
      real(Size4) sec4, tsjstor, tsimpjf, dtimpjf,time0
      integer:: ivcount
      integer:: omp_get_thread_num,tid
c       time0=gettime(sec4) #here

ccc ... Only perturb variables that are being solved for (for Daspk option)
ccc      if (iseqon(iv) .eq. 0) goto 18

c ... Set beginning and ending indices of right-hand sides that might be
c     perturbed.
       tid=omp_get_thread_num()
         nnz=1
         ivcount=0
        do iv=ivmin,ivmax
           ivcount=ivcount+1
         ii1 = max(iv-mu, 1)
         ii2 = min(iv+ml, neq)
c ... Reset range if this is a potential perturbation with isnewpot=1
ccc         if (isphion*isnewpot.eq.1 .and. mod(iv,numvar).eq.0) then
         if (isphion*isnewpot.eq.1) then
            ii1 = max(iv-4*numvar*nx, 1)      # 3*nx may be excessive
            ii2 = min(iv+4*numvar*nx, neq)    # 3*nx may be excessive
         endif
c ... Reset range if extrapolation boundary conditions are used
         if (isextrnpf+isextrtpf+isextrngc+isextrnw+isextrtw.gt.0) then
            ii1 = max(iv-2*numvar*(nx+3), 1)      # guess to include extrap. bc
            ii2 = min(iv+2*numvar*(nx+3), neq)    # guess to include extrap. bc
         endif

c ... Initialize all of those right-hand sides to their unperturbed
c     values.

         do ii = ii1, ii2   # a) below wk is reset, but only over limited range
            wk(ii) = yldot00(ii)
         enddo

c ... Set spatial-location indices for this dependent variable.
         xc = igyl(iv,1)
         yc = igyl(iv,2)

c ... Save value of dependent variable, then perturb it.
c     The perturbation to the variable is proportional to parameter
c     del and to a measure of the size of the variable.  That measure
c     increases with the absolute value of the variable if it exceeds
c     the typical size given by dylconst/suscal but can never be less
c     than that typical size.
         yold = yl(iv)
         dyl = delperturb * (abs(yold) + dylconst / suscal(iv))
         yl(iv) = yold + dyl
c ... Calculate right-hand sides near location of perturbed variable.
ccc         call convsr_vo (xc, yc, yl)  # test new convsr placement
ccc         call convsr_aux (xc, yc, yl) # test new convsr placement

         call pandf1 (xc, yc, iv, neq, t, yl, wk)


ccc         yl(iv) = yold - dyl    # for 2nd order Jac
ccc         call pandf1 (xc, yc, iv, neq, t, yl, yldot0) # for 2nd order Jac
c ... Calculate possibly nonzero Jacobian elements for this variable,
c     and store nonzero elements in compressed sparse column format.
         iJacRow(iv) = nnz      # sets index for first Jac. elem. of var. iv

c############### loop ii

         do ii = ii1, ii2

c dtuse,iseqalg,jacelem,idxphi,dtphi,sfscal,jaccliplim,nnzmx

            jacelem = (wk(ii) - yldot00(ii)) / dyl
ccc            jacelem = (wk/(ii) - yldot0(ii)) / (2*dyl)  # for 2nd order Jac
c ...  Add diagonal 1/dt for nksol
      if (((svrpkg.eq."nksol") .or. (svrpkg.eq."petsc")) .and. iv.eq.ii)
     .then
              if (iseqalg(iv)*(1-isbcwdt).eq.0) then
                jacelem = jacelem - 1/dtuse(iv)
              endif
              ix = igyl(iv,1)
              iy = igyl(iv,2)
              if (idxphi(ix,iy)==iv .and. dtphi<1e10) then #selects phi eqn
                jacelem = jacelem - 1/dtphi
              endif

       endif

c ...  Add a pseudo timestep to the diagonal ## if eqn is not algebraic
       if (svrpkg .ne. "cvode" .and. nufak .gt. 0) then
               if (iv.eq.ii .and. yl(neq+1).eq.1)
     .          jacelem = jacelem - nufak  #omit .and. iseqalg(iv).eq.0)
cc     .                   jacelem = jacelem - nufak*suscal(iv)/sfscal(iv)
               endif
        if (ii==iidebugprint.and.iv==ivdebugprint) then
        write(iout*,'(a,i3,a,i7,i7,i7, E20.12,E20.12,E20.12,E20.12,E20.12,E20.12)') '#', 0,' : ',iv,nnz,
     .ii,jacelem,wk(ii),yldot00(ii),sfscal(iv),jaccliplim,nufak
        call DebugHelper('dumpomp.txt')
        endif

        if (abs(jacelem*sfscal(iv)) .gt. jaccliplim) then

               if (nnz .gt. nnzmx) then
                  write(iout*,*) nnz,nnzmx
                  write(ioutSTDOUT,*)
     .             'ith',ith,'*** jac_calc -- More storage needed for Jacobian.',
     .             ' Storage exceeded at (i,j) = (',ii,',',iv,').',
     .             ' Increase lenpfac.'
	              call xerrab("")
               endif
cc               if (rdoff.ne.0.e0) jacelem=jacelem*(1.0e0+ranf()*rdoff)
             iJacCol(nnz)=ii
            rJacElem(nnz)=jacelem
            nnz = nnz + 1

         endif

             if (istopjac.gt.0 .and. ii.eq.irstop .and. iv.eq.icstop) then
ccc               yldot_pert(ii) = wk(ii)      # for diagnostic only
                   if (istopjac == 2) then
                     yl(iv) = yold
                     call pandf1 (xc, yc, iv, neq, t, yl, wk)
                   endif
ccc               call convsr_vo (xc, yc, yl)  # was one call to convsr
ccc               call convsr_aux (xc, yc, yl)
                   call remark("***** non-zero jac_elem at irstop,icstop")
                  write(iout*,*) 'irstop = ', irstop, ', icstop = ', icstop
                   call xerrab("")
             endif
         enddo  # end of ii loop over equations


c ... Restore dependent variable and plasma variables near its location.
         yl(iv) = yold
ccc         call convsr_vo (xc, yc, yl)  # was one call to convsr
ccc         call convsr_aux (xc, yc, yl)

         call pandf1 (xc, yc, iv, neq, t, yl, wk)

         yldot_pert(1:neq)=wk(1:neq)
ccc 18   continue
c...  If this is the last variable before jumping to new cell, reset pandf

         if (mod(iv,numvar).eq.0 .and. isjacreset.ge.1) then

           call pandf1 (xc, yc, iv, neq, t, yl, wk)
         endif
         if( isjacreset.ge.1) then
         yldot_pert(1:neq)=wk(1:neq)
ccc 18   continue
c...  If this is the last variable before jumping to new cell, reset pandf
cJG this call to pandf1 can be safely ignored with ijacreset=0 (and save some time...)
         if (mod(iv,numvar).eq.0) then
            call pandf1 (xc, yc, iv, neq, t, yl, wk)
         endif

         do ii=1,neq
         if (yldot_pert(ii).ne.wk(ii)) then
      write(iout*,'(a,i5,e20.12,e20.12)') ' *** wk modified on second call to pandf1 at ii=',
     . ii,yldot_pert(ii),wk(ii)
         call xerrab('*** Stop ***')
         endif
         if (isnan(yldot_pert(ii))) then
         write(iout*,*) 'ii=',ii
         call xerrab('*** Nan in wk array in jac_calc ***')
         endif

         enddo
         endif
      enddo
c ... End loop over dependent variables and finish Jacobian storage.
      end subroutine LocalJacBuilder

cJG some routine from blas are put here to allow the sementic analysis of the fortran code to determine variables which must be threadprivate
            SUBROUTINE scopy(N,SX,INCX,SY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
        INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
        REAL SX(*),SY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
        INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
        INTRINSIC mod
*     ..
       IF (n.LE.0) RETURN
       IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
              m = mod(n,7)
              IF (m.NE.0) THEN
                 DO i = 1,m
                    sy(i) = sx(i)
                 END DO
                 IF (n.LT.7) RETURN
              END IF
              mp1 = m + 1
              DO i = mp1,n,7
                 sy(i) = sx(i)
                 sy(i+1) = sx(i+1)
                 sy(i+2) = sx(i+2)
                 sy(i+3) = sx(i+3)
                 sy(i+4) = sx(i+4)
                 sy(i+5) = sx(i+5)
                 sy(i+6) = sx(i+6)
              END DO
           ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
          ix = 1
          iy = 1
          IF (incx.LT.0) ix = (-n+1)*incx + 1
          IF (incy.LT.0) iy = (-n+1)*incy + 1
          DO i = 1,n
             sy(iy) = sx(ix)
             ix = ix + incx
             iy = iy + incy
          END DO
       END IF
       RETURN
       END


       SUBROUTINE saxpy(N,SA,SX,INCX,SY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
       REAL SA
       INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
       REAL SX(*),SY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
       INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
       INTRINSIC mod
*     ..
       IF (n.LE.0) RETURN
       IF (sa.EQ.0.0) RETURN
       IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
          m = mod(n,4)
          IF (m.NE.0) THEN
             DO i = 1,m
                sy(i) = sy(i) + sa*sx(i)
             END DO
          END IF
          IF (n.LT.4) RETURN
          mp1 = m + 1
          DO i = mp1,n,4
             sy(i) = sy(i) + sa*sx(i)
             sy(i+1) = sy(i+1) + sa*sx(i+1)
             sy(i+2) = sy(i+2) + sa*sx(i+2)
             sy(i+3) = sy(i+3) + sa*sx(i+3)
          END DO
       ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
          ix = 1
          iy = 1
          IF (incx.LT.0) ix = (-n+1)*incx + 1
          IF (incy.LT.0) iy = (-n+1)*incy + 1
          DO i = 1,n
           sy(iy) = sy(iy) + sa*sx(ix)
           ix = ix + incx
           iy = iy + incy
          END DO
       END IF
       RETURN
       END

             subroutine sgefa(a,lda,n,ipvt,info)
      integer lda,n,ipvt(1),info
      real a(lda,1)
c
c     sgefa factors a real matrix by gaussian elimination.
c
c     sgefa is usually called by sgeco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c     (time for sgeco) = (1 + 9/n)*(time for sgefa) .
c
c     on entry
c
c        a       real(lda, n)
c                the matrix to be factored.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       an upper triangular matrix and the multipliers
c                which were used to obtain it.
c                the factorization can be written  a = l*u  where
c                l  is a product of permutation and unit lower
c                triangular matrices and  u  is upper triangular.
c
c        ipvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if  u(k,k) .eq. 0.0 .  this is not an error
c                     condition for this subroutine, but it does
c                     indicate that sgesl or sgedi will divide by zero
c                     if called.  use  rcond  in sgeco for a reliable
c                     indication of singularity.
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas saxpy,sscal,isamax
c
c     internal variables
c
      real t
      integer isamax,j,k,kp1,l,nm1
c
c
c     gaussian elimination with partial pivoting
c
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
c
c        find l = pivot index
c
         l = isamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
c
c        zero pivot implies this column already triangularized
c
         if (a(l,k) .eq. 0.0e0) go to 40
c
c           interchange if necessary
c
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
c
c           compute multipliers
c
            t = -1.0e0/a(k,k)
            call sscal(n-k,t,a(k+1,k),1)
c
c           row elimination with column indexing
c
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20
                  a(l,j) = a(k,j)
                  a(k,j) = t
   20          continue
               call saxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue
   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0e0) info = n
      return
      end

      subroutine WriteArrayReal(array,s,iu)
      implicit none
      real:: array(*)
      integer:: i,s,iu
      do i=1,s
      write(ioutiu,*) array(i)
      enddo
      end subroutine WriteArrayReal

      subroutine WriteArrayInteger(array,s,iu)
      implicit none
      integer:: array(*)
      integer:: i,s,iu
      do i=1,s
      write(ioutiu,*) array(i)
      enddo
      end subroutine WriteArrayInteger
cJG 03/2020 Subroutine for debugging purpose: print out all the threadprivate variable.
cJG This routine was created with the OMPDebugger.py script, which also contains methods to analyze the outpout of this routine.
cJG This routine can be called within the jacobian constructor to determine which variables behave differenlty in serial vs openmp jacobian calculations
      subroutine DebugHelper(FileName)
      implicit none
      integer,parameter:: iunit=777
      character(len = *) ::  filename

      Use(Bcond)
      Use(Cfric)
      Use(Coefeq)
      Use(Comflo)
      Use(Comgeo)
      Use(Compla)
      Use(Comtra)
      Use(Conduc)
      Use(Dim)
      Use(Gradients)
      Use(Imprad)
      Use(Locflux)
      Use(MCN_sources)
      Use(PNC_params)
      Use(Rhsides)
      Use(Save_terms)
      Use(Selec)
      Use(Time_dep_nwt)
      Use(Timing)
      Use(UEpar)
      Use(Wkspace)
c$ omp  parallel default(firstprivate)
      open (unit = iunit, file = trim(filename))
      write(ioutiunit,*) "alfneo"
      call WriteArrayReal(alfneo,size(alfneo),iunit)
      write(ioutiunit,*) "betap"
      call WriteArrayReal(betap,size(betap),iunit)
      write(ioutiunit,*) "cfneut"
      write(ioutiunit,*) cfneut
      write(ioutiunit,*) "cfneutdiv"
      write(ioutiunit,*) cfneutdiv
      write(ioutiunit,*) "cfvcsx"
      call WriteArrayReal(cfvcsx,size(cfvcsx),iunit)
      write(ioutiunit,*) "cfvcsy"
      call WriteArrayReal(cfvcsy,size(cfvcsy),iunit)
      write(ioutiunit,*) "cfvgpx"
      call WriteArrayReal(cfvgpx,size(cfvgpx),iunit)
      write(ioutiunit,*) "cfvgpy"
      call WriteArrayReal(cfvgpy,size(cfvgpy),iunit)
      write(ioutiunit,*) "cmneut"
      write(ioutiunit,*) cmneut
      write(ioutiunit,*) "cmneutdiv"
      write(ioutiunit,*) cmneutdiv
      write(ioutiunit,*) "coef1"
      write(ioutiunit,*) coef1
      write(ioutiunit,*) "coll_fe"
      call WriteArrayReal(coll_fe,size(coll_fe),iunit)
      write(ioutiunit,*) "coll_fi"
      call WriteArrayReal(coll_fi,size(coll_fi),iunit)
      write(ioutiunit,*) "conx"
      call WriteArrayReal(conx,size(conx),iunit)
      write(ioutiunit,*) "conxe"
      call WriteArrayReal(conxe,size(conxe),iunit)
      write(ioutiunit,*) "conxi"
      call WriteArrayReal(conxi,size(conxi),iunit)
      write(ioutiunit,*) "cony"
      call WriteArrayReal(cony,size(cony),iunit)
      write(ioutiunit,*) "conye"
      call WriteArrayReal(conye,size(conye),iunit)
      write(ioutiunit,*) "conyi"
      call WriteArrayReal(conyi,size(conyi),iunit)
      write(ioutiunit,*) "cs"
      write(ioutiunit,*) cs
      write(ioutiunit,*) "csh"
      write(ioutiunit,*) csh
      write(ioutiunit,*) "ctaue"
      write(ioutiunit,*) ctaue
      write(ioutiunit,*) "ctaui"
      write(ioutiunit,*) ctaui
      write(ioutiunit,*) "dclass_e"
      call WriteArrayReal(dclass_e,size(dclass_e),iunit)
      write(ioutiunit,*) "dclass_i"
      call WriteArrayReal(dclass_i,size(dclass_i),iunit)
      write(ioutiunit,*) "dif2_use"
      call WriteArrayReal(dif2_use,size(dif2_use),iunit)
      write(ioutiunit,*) "dif_use"
      call WriteArrayReal(dif_use,size(dif_use),iunit)
      write(ioutiunit,*) "diffusivwrk"
      call WriteArrayReal(diffusivwrk,size(diffusivwrk),iunit)
      write(ioutiunit,*) "difp_use"
      call WriteArrayReal(difp_use,size(difp_use),iunit)
      write(ioutiunit,*) "dp1"
      write(ioutiunit,*) dp1
      write(ioutiunit,*) "dtold"
      write(ioutiunit,*) dtold
      write(ioutiunit,*) "dtreal"
      write(ioutiunit,*) dtreal
      write(ioutiunit,*) "dutm_use"
      call WriteArrayReal(dutm_use,size(dutm_use),iunit)
      write(ioutiunit,*) "eeli"
      call WriteArrayReal(eeli,size(eeli),iunit)
      write(ioutiunit,*) "eqp"
      call WriteArrayReal(eqp,size(eqp),iunit)
      write(ioutiunit,*) "eqpg"
      call WriteArrayReal(eqpg,size(eqpg),iunit)
      write(ioutiunit,*) "erliz"
      call WriteArrayReal(erliz,size(erliz),iunit)
      write(ioutiunit,*) "erlrc"
      call WriteArrayReal(erlrc,size(erlrc),iunit)
      write(ioutiunit,*) "eta1"
      call WriteArrayReal(eta1,size(eta1),iunit)
      write(ioutiunit,*) "ex"
      call WriteArrayReal(ex,size(ex),iunit)
      write(ioutiunit,*) "ey"
      call WriteArrayReal(ey,size(ey),iunit)
      write(ioutiunit,*) "fcdif"
      write(ioutiunit,*) fcdif
      write(ioutiunit,*) "fdiaxlb"
      call WriteArrayReal(fdiaxlb,size(fdiaxlb),iunit)
      write(ioutiunit,*) "fdiaxrb"
      call WriteArrayReal(fdiaxrb,size(fdiaxrb),iunit)
      write(ioutiunit,*) "feex"
      call WriteArrayReal(feex,size(feex),iunit)
      write(ioutiunit,*) "feexy"
      call WriteArrayReal(feexy,size(feexy),iunit)
      write(ioutiunit,*) "feey"
      call WriteArrayReal(feey,size(feey),iunit)
      write(ioutiunit,*) "feey4ord"
      call WriteArrayReal(feey4ord,size(feey4ord),iunit)
      write(ioutiunit,*) "feeycbo"
      call WriteArrayReal(feeycbo,size(feeycbo),iunit)
      write(ioutiunit,*) "feix"
      call WriteArrayReal(feix,size(feix),iunit)
      write(ioutiunit,*) "feixy"
      call WriteArrayReal(feixy,size(feixy),iunit)
      write(ioutiunit,*) "feiy"
      call WriteArrayReal(feiy,size(feiy),iunit)
      write(ioutiunit,*) "feiy4ord"
      call WriteArrayReal(feiy4ord,size(feiy4ord),iunit)
      write(ioutiunit,*) "feiycbo"
      call WriteArrayReal(feiycbo,size(feiycbo),iunit)
      write(ioutiunit,*) "flox"
      call WriteArrayReal(flox,size(flox),iunit)
      write(ioutiunit,*) "floxe"
      call WriteArrayReal(floxe,size(floxe),iunit)
      write(ioutiunit,*) "floxebgt"
      call WriteArrayReal(floxebgt,size(floxebgt),iunit)
      write(ioutiunit,*) "floxi"
      call WriteArrayReal(floxi,size(floxi),iunit)
      write(ioutiunit,*) "floxibgt"
      call WriteArrayReal(floxibgt,size(floxibgt),iunit)
      write(ioutiunit,*) "floy"
      call WriteArrayReal(floy,size(floy),iunit)
      write(ioutiunit,*) "floye"
      call WriteArrayReal(floye,size(floye),iunit)
      write(ioutiunit,*) "floyi"
      call WriteArrayReal(floyi,size(floyi),iunit)
      write(ioutiunit,*) "fmihxpt"
      call WriteArrayReal(fmihxpt,size(fmihxpt),iunit)
      write(ioutiunit,*) "fmivxpt"
      call WriteArrayReal(fmivxpt,size(fmivxpt),iunit)
      write(ioutiunit,*) "fmix"
      call WriteArrayReal(fmix,size(fmix),iunit)
      write(ioutiunit,*) "fmixy"
      call WriteArrayReal(fmixy,size(fmixy),iunit)
      write(ioutiunit,*) "fmiy"
      call WriteArrayReal(fmiy,size(fmiy),iunit)
      write(ioutiunit,*) "fnix"
      call WriteArrayReal(fnix,size(fnix),iunit)
      write(ioutiunit,*) "fnixcb"
      call WriteArrayReal(fnixcb,size(fnixcb),iunit)
      write(ioutiunit,*) "fniy"
      call WriteArrayReal(fniy,size(fniy),iunit)
      write(ioutiunit,*) "fniy4ord"
      call WriteArrayReal(fniy4ord,size(fniy4ord),iunit)
      write(ioutiunit,*) "fniycb"
      call WriteArrayReal(fniycb,size(fniycb),iunit)
      write(ioutiunit,*) "fniycbo"
      call WriteArrayReal(fniycbo,size(fniycbo),iunit)
      write(ioutiunit,*) "fqp"
      call WriteArrayReal(fqp,size(fqp),iunit)
      write(ioutiunit,*) "frice"
      call WriteArrayReal(frice,size(frice),iunit)
      write(ioutiunit,*) "frici"
      call WriteArrayReal(frici,size(frici),iunit)
      write(ioutiunit,*) "fricnrl"
      call WriteArrayReal(fricnrl,size(fricnrl),iunit)
      write(ioutiunit,*) "fxe"
      write(ioutiunit,*) fxe
      write(ioutiunit,*) "fxi"
      write(ioutiunit,*) fxi
      write(ioutiunit,*) "ghxpt"
      write(ioutiunit,*) ghxpt
      write(ioutiunit,*) "gpex"
      call WriteArrayReal(gpex,size(gpex),iunit)
      write(ioutiunit,*) "gpey"
      call WriteArrayReal(gpey,size(gpey),iunit)
      write(ioutiunit,*) "gpix"
      call WriteArrayReal(gpix,size(gpix),iunit)
      write(ioutiunit,*) "gpiy"
      call WriteArrayReal(gpiy,size(gpiy),iunit)
      write(ioutiunit,*) "gprx"
      call WriteArrayReal(gprx,size(gprx),iunit)
      write(ioutiunit,*) "gpry"
      call WriteArrayReal(gpry,size(gpry),iunit)
      write(ioutiunit,*) "gtex"
      call WriteArrayReal(gtex,size(gtex),iunit)
      write(ioutiunit,*) "gtey"
      call WriteArrayReal(gtey,size(gtey),iunit)
      write(ioutiunit,*) "gtix"
      call WriteArrayReal(gtix,size(gtix),iunit)
      write(ioutiunit,*) "gtiy"
      call WriteArrayReal(gtiy,size(gtiy),iunit)
      write(ioutiunit,*) "gvxpt"
      write(ioutiunit,*) gvxpt
      write(ioutiunit,*) "hcxe"
      call WriteArrayReal(hcxe,size(hcxe),iunit)
      write(ioutiunit,*) "hcxg"
      call WriteArrayReal(hcxg,size(hcxg),iunit)
      write(ioutiunit,*) "hcxi"
      call WriteArrayReal(hcxi,size(hcxi),iunit)
      write(ioutiunit,*) "hcxij"
      call WriteArrayReal(hcxij,size(hcxij),iunit)
      write(ioutiunit,*) "hcxineo"
      call WriteArrayReal(hcxineo,size(hcxineo),iunit)
      write(ioutiunit,*) "hcxn"
      call WriteArrayReal(hcxn,size(hcxn),iunit)
      write(ioutiunit,*) "hcye"
      call WriteArrayReal(hcye,size(hcye),iunit)
      write(ioutiunit,*) "hcyg"
      call WriteArrayReal(hcyg,size(hcyg),iunit)
      write(ioutiunit,*) "hcyi"
      call WriteArrayReal(hcyi,size(hcyi),iunit)
      write(ioutiunit,*) "hcyij"
      call WriteArrayReal(hcyij,size(hcyij),iunit)
      write(ioutiunit,*) "hcyn"
      call WriteArrayReal(hcyn,size(hcyn),iunit)
      write(ioutiunit,*) "i1"
      write(ioutiunit,*) i1
      write(ioutiunit,*) "i2"
      write(ioutiunit,*) i2
      write(ioutiunit,*) "i2p"
      write(ioutiunit,*) i2p
      write(ioutiunit,*) "i3"
      write(ioutiunit,*) i3
      write(ioutiunit,*) "i4"
      write(ioutiunit,*) i4
      write(ioutiunit,*) "i5"
      write(ioutiunit,*) i5
      write(ioutiunit,*) "i5m"
      write(ioutiunit,*) i5m
      write(ioutiunit,*) "i6"
      write(ioutiunit,*) i6
      write(ioutiunit,*) "i7"
      write(ioutiunit,*) i7
      write(ioutiunit,*) "i8"
      write(ioutiunit,*) i8
      write(ioutiunit,*) "ixf6"
      write(ioutiunit,*) ixf6
      write(ioutiunit,*) "ixs1"
      write(ioutiunit,*) ixs1
      write(ioutiunit,*) "iyf6"
      write(ioutiunit,*) iyf6
      write(ioutiunit,*) "iys1"
      write(ioutiunit,*) iys1
      write(ioutiunit,*) "j1"
      write(ioutiunit,*) j1
      write(ioutiunit,*) "j1p"
      write(ioutiunit,*) j1p
      write(ioutiunit,*) "j2"
      write(ioutiunit,*) j2
      write(ioutiunit,*) "j2p"
      write(ioutiunit,*) j2p
      write(ioutiunit,*) "j3"
      write(ioutiunit,*) j3
      write(ioutiunit,*) "j4"
      write(ioutiunit,*) j4
      write(ioutiunit,*) "j5"
      write(ioutiunit,*) j5
      write(ioutiunit,*) "j5m"
      write(ioutiunit,*) j5m
      write(ioutiunit,*) "j5p"
      write(ioutiunit,*) j5p
      write(ioutiunit,*) "j6"
      write(ioutiunit,*) j6
      write(ioutiunit,*) "j6p"
      write(ioutiunit,*) j6p
      write(ioutiunit,*) "j7"
      write(ioutiunit,*) j7
      write(ioutiunit,*) "j8"
      write(ioutiunit,*) j8
      write(ioutiunit,*) "k2neo"
      call WriteArrayReal(k2neo,size(k2neo),iunit)
      write(ioutiunit,*) "ktneo"
      call WriteArrayReal(ktneo,size(ktneo),iunit)
      write(ioutiunit,*) "kxbohm"
      call WriteArrayReal(kxbohm,size(kxbohm),iunit)
      write(ioutiunit,*) "kxe_use"
      call WriteArrayReal(kxe_use,size(kxe_use),iunit)
      write(ioutiunit,*) "kxi_use"
      call WriteArrayReal(kxi_use,size(kxi_use),iunit)
      write(ioutiunit,*) "kybohm"
      call WriteArrayReal(kybohm,size(kybohm),iunit)
      write(ioutiunit,*) "kye_use"
      call WriteArrayReal(kye_use,size(kye_use),iunit)
      write(ioutiunit,*) "kyi_use"
      call WriteArrayReal(kyi_use,size(kyi_use),iunit)
      write(ioutiunit,*) "lng"
      call WriteArrayReal(lng,size(lng),iunit)
      write(ioutiunit,*) "mfl"
      write(ioutiunit,*) mfl
      write(ioutiunit,*) "msh"
      write(ioutiunit,*) msh
      write(ioutiunit,*) "msor"
      call WriteArrayReal(msor,size(msor),iunit)
      write(ioutiunit,*) "msorold"
      call WriteArrayReal(msorold,size(msorold),iunit)
      write(ioutiunit,*) "msorxr"
      call WriteArrayReal(msorxr,size(msorxr),iunit)
      write(ioutiunit,*) "msorxrold"
      call WriteArrayReal(msorxrold,size(msorxrold),iunit)
      write(ioutiunit,*) "na"
      call WriteArrayReal(na,size(na),iunit)
      write(ioutiunit,*) "ne"
      call WriteArrayReal(ne,size(ne),iunit)
      write(ioutiunit,*) "ney0"
      call WriteArrayReal(ney0,size(ney0),iunit)
      write(ioutiunit,*) "ney1"
      call WriteArrayReal(ney1,size(ney1),iunit)
      write(ioutiunit,*) "nfsp"
      write(ioutiunit,*) nfsp
      write(ioutiunit,*) "ng"
      call WriteArrayReal(ng,size(ng),iunit)
      write(ioutiunit,*) "ngy0"
      call WriteArrayReal(ngy0,size(ngy0),iunit)
      write(ioutiunit,*) "ngy1"
      call WriteArrayReal(ngy1,size(ngy1),iunit)
      write(ioutiunit,*) "ni"
      call WriteArrayReal(ni,size(ni),iunit)
      write(ioutiunit,*) "nit"
      call WriteArrayReal(nit,size(nit),iunit)
      write(ioutiunit,*) "nity0"
      call WriteArrayReal(nity0,size(nity0),iunit)
      write(ioutiunit,*) "nity1"
      call WriteArrayReal(nity1,size(nity1),iunit)
      write(ioutiunit,*) "nixpt"
      call WriteArrayReal(nixpt,size(nixpt),iunit)
      write(ioutiunit,*) "niy0"
      call WriteArrayReal(niy0,size(niy0),iunit)
      write(ioutiunit,*) "niy0s"
      call WriteArrayReal(niy0s,size(niy0s),iunit)
      write(ioutiunit,*) "niy1"
      call WriteArrayReal(niy1,size(niy1),iunit)
      write(ioutiunit,*) "niy1s"
      call WriteArrayReal(niy1s,size(niy1s),iunit)
      write(ioutiunit,*) "nm"
      call WriteArrayReal(nm,size(nm),iunit)
      write(ioutiunit,*) "nratio"
      call WriteArrayReal(nratio,size(nratio),iunit)
      write(ioutiunit,*) "ntau"
      call WriteArrayReal(ntau,size(ntau),iunit)
      write(ioutiunit,*) "nucx"
      call WriteArrayReal(nucx,size(nucx),iunit)
      write(ioutiunit,*) "nucxi"
      call WriteArrayReal(nucxi,size(nucxi),iunit)
      write(ioutiunit,*) "nuelg"
      call WriteArrayReal(nuelg,size(nuelg),iunit)
      write(ioutiunit,*) "nueli"
      call WriteArrayReal(nueli,size(nueli),iunit)
      write(ioutiunit,*) "nuii"
      call WriteArrayReal(nuii,size(nuii),iunit)
      write(ioutiunit,*) "nuiistar"
      call WriteArrayReal(nuiistar,size(nuiistar),iunit)
      write(ioutiunit,*) "nuix"
      call WriteArrayReal(nuix,size(nuix),iunit)
      write(ioutiunit,*) "nuiz"
      call WriteArrayReal(nuiz,size(nuiz),iunit)
      write(ioutiunit,*) "nurc"
      call WriteArrayReal(nurc,size(nurc),iunit)
      write(ioutiunit,*) "nuvl"
      call WriteArrayReal(nuvl,size(nuvl),iunit)
      write(ioutiunit,*) "nz2"
      call WriteArrayReal(nz2,size(nz2),iunit)
      write(ioutiunit,*) "nzloc"
      call WriteArrayReal(nzloc,size(nzloc),iunit)
      write(ioutiunit,*) "openbox"
      write(ioutiunit,*) openbox
      write(ioutiunit,*) "parvis"
      call WriteArrayReal(parvis,size(parvis),iunit)
      write(ioutiunit,*) "pg"
      call WriteArrayReal(pg,size(pg),iunit)
      write(ioutiunit,*) "pgy0"
      call WriteArrayReal(pgy0,size(pgy0),iunit)
      write(ioutiunit,*) "pgy1"
      call WriteArrayReal(pgy1,size(pgy1),iunit)
      write(ioutiunit,*) "phi"
      call WriteArrayReal(phi,size(phi),iunit)
      write(ioutiunit,*) "phiv"
      call WriteArrayReal(phiv,size(phiv),iunit)
      write(ioutiunit,*) "phiy0"
      call WriteArrayReal(phiy0,size(phiy0),iunit)
      write(ioutiunit,*) "phiy0s"
      call WriteArrayReal(phiy0s,size(phiy0s),iunit)
      write(ioutiunit,*) "phiy1"
      call WriteArrayReal(phiy1,size(phiy1),iunit)
      write(ioutiunit,*) "phiy1s"
      call WriteArrayReal(phiy1s,size(phiy1s),iunit)
      write(ioutiunit,*) "pr"
      call WriteArrayReal(pr,size(pr),iunit)
      write(ioutiunit,*) "prad"
      call WriteArrayReal(prad,size(prad),iunit)
      write(ioutiunit,*) "pradc"
      call WriteArrayReal(pradc,size(pradc),iunit)
      write(ioutiunit,*) "pradcff"
      call WriteArrayReal(pradcff,size(pradcff),iunit)
      write(ioutiunit,*) "pradz"
      call WriteArrayReal(pradz,size(pradz),iunit)
      write(ioutiunit,*) "pradzc"
      call WriteArrayReal(pradzc,size(pradzc),iunit)
      write(ioutiunit,*) "pre"
      call WriteArrayReal(pre,size(pre),iunit)
      write(ioutiunit,*) "prev"
      call WriteArrayReal(prev,size(prev),iunit)
      write(ioutiunit,*) "pri"
      call WriteArrayReal(pri,size(pri),iunit)
      write(ioutiunit,*) "priv"
      call WriteArrayReal(priv,size(priv),iunit)
      write(ioutiunit,*) "priy0"
      call WriteArrayReal(priy0,size(priy0),iunit)
      write(ioutiunit,*) "priy1"
      call WriteArrayReal(priy1,size(priy1),iunit)
      write(ioutiunit,*) "prtv"
      call WriteArrayReal(prtv,size(prtv),iunit)
      write(ioutiunit,*) "psor"
      call WriteArrayReal(psor,size(psor),iunit)
      write(ioutiunit,*) "psor_tmpov"
      call WriteArrayReal(psor_tmpov,size(psor_tmpov),iunit)
      write(ioutiunit,*) "psorbgg"
      call WriteArrayReal(psorbgg,size(psorbgg),iunit)
      write(ioutiunit,*) "psorbgz"
      call WriteArrayReal(psorbgz,size(psorbgz),iunit)
      write(ioutiunit,*) "psorc"
      call WriteArrayReal(psorc,size(psorc),iunit)
      write(ioutiunit,*) "psorcxg"
      call WriteArrayReal(psorcxg,size(psorcxg),iunit)
      write(ioutiunit,*) "psorcxgc"
      call WriteArrayReal(psorcxgc,size(psorcxgc),iunit)
      write(ioutiunit,*) "psordis"
      call WriteArrayReal(psordis,size(psordis),iunit)
      write(ioutiunit,*) "psorg"
      call WriteArrayReal(psorg,size(psorg),iunit)
      write(ioutiunit,*) "psorgc"
      call WriteArrayReal(psorgc,size(psorgc),iunit)
      write(ioutiunit,*) "psori"
      call WriteArrayReal(psori,size(psori),iunit)
      write(ioutiunit,*) "psorold"
      call WriteArrayReal(psorold,size(psorold),iunit)
      write(ioutiunit,*) "psorrg"
      call WriteArrayReal(psorrg,size(psorrg),iunit)
      write(ioutiunit,*) "psorrgc"
      call WriteArrayReal(psorrgc,size(psorrgc),iunit)
      write(ioutiunit,*) "psorxr"
      call WriteArrayReal(psorxr,size(psorxr),iunit)
      write(ioutiunit,*) "psorxrc"
      call WriteArrayReal(psorxrc,size(psorxrc),iunit)
      write(ioutiunit,*) "psorxrold"
      call WriteArrayReal(psorxrold,size(psorxrold),iunit)
      write(ioutiunit,*) "pwrebkg"
      call WriteArrayReal(pwrebkg,size(pwrebkg),iunit)
      write(ioutiunit,*) "pwribkg"
      call WriteArrayReal(pwribkg,size(pwribkg),iunit)
      write(ioutiunit,*) "pwrze"
      call WriteArrayReal(pwrze,size(pwrze),iunit)
      write(ioutiunit,*) "pwrzec"
      call WriteArrayReal(pwrzec,size(pwrzec),iunit)
      write(ioutiunit,*) "q2cd"
      call WriteArrayReal(q2cd,size(q2cd),iunit)
      write(ioutiunit,*) "qfl"
      write(ioutiunit,*) qfl
      write(ioutiunit,*) "qipar"
      call WriteArrayReal(qipar,size(qipar),iunit)
      write(ioutiunit,*) "qsh"
      write(ioutiunit,*) qsh
      write(ioutiunit,*) "resco"
      call WriteArrayReal(resco,size(resco),iunit)
      write(ioutiunit,*) "resee"
      call WriteArrayReal(resee,size(resee),iunit)
      write(ioutiunit,*) "resei"
      call WriteArrayReal(resei,size(resei),iunit)
      write(ioutiunit,*) "resmo"
      call WriteArrayReal(resmo,size(resmo),iunit)
      write(ioutiunit,*) "rtau"
      call WriteArrayReal(rtau,size(rtau),iunit)
      write(ioutiunit,*) "rtaue"
      call WriteArrayReal(rtaue,size(rtaue),iunit)
      write(ioutiunit,*) "rtaux"
      call WriteArrayReal(rtaux,size(rtaux),iunit)
      write(ioutiunit,*) "rtauy"
      call WriteArrayReal(rtauy,size(rtauy),iunit)
      write(ioutiunit,*) "seec"
      call WriteArrayReal(seec,size(seec),iunit)
      write(ioutiunit,*) "seev"
      call WriteArrayReal(seev,size(seev),iunit)
      write(ioutiunit,*) "seg_ue"
      call WriteArrayReal(seg_ue,size(seg_ue),iunit)
      write(ioutiunit,*) "seic"
      call WriteArrayReal(seic,size(seic),iunit)
      write(ioutiunit,*) "seiv"
      call WriteArrayReal(seiv,size(seiv),iunit)
      write(ioutiunit,*) "smoc"
      call WriteArrayReal(smoc,size(smoc),iunit)
      write(ioutiunit,*) "smov"
      call WriteArrayReal(smov,size(smov),iunit)
      write(ioutiunit,*) "sng_ue"
      call WriteArrayReal(sng_ue,size(sng_ue),iunit)
      write(ioutiunit,*) "snic"
      call WriteArrayReal(snic,size(snic),iunit)
      write(ioutiunit,*) "sniv"
      call WriteArrayReal(sniv,size(sniv),iunit)
      write(ioutiunit,*) "sxyxpt"
      write(ioutiunit,*) sxyxpt
      write(ioutiunit,*) "te"
      call WriteArrayReal(te,size(te),iunit)
      write(ioutiunit,*) "tev"
      call WriteArrayReal(tev,size(tev),iunit)
      write(ioutiunit,*) "tey0"
      call WriteArrayReal(tey0,size(tey0),iunit)
      write(ioutiunit,*) "tey1"
      call WriteArrayReal(tey1,size(tey1),iunit)
      write(ioutiunit,*) "tg"
      call WriteArrayReal(tg,size(tg),iunit)
      write(ioutiunit,*) "tgy0"
      call WriteArrayReal(tgy0,size(tgy0),iunit)
      write(ioutiunit,*) "tgy1"
      call WriteArrayReal(tgy1,size(tgy1),iunit)
      write(ioutiunit,*) "ti"
      call WriteArrayReal(ti,size(ti),iunit)
      write(ioutiunit,*) "tiv"
      call WriteArrayReal(tiv,size(tiv),iunit)
      write(ioutiunit,*) "tiy0"
      call WriteArrayReal(tiy0,size(tiy0),iunit)
      write(ioutiunit,*) "tiy0s"
      call WriteArrayReal(tiy0s,size(tiy0s),iunit)
      write(ioutiunit,*) "tiy1"
      call WriteArrayReal(tiy1,size(tiy1),iunit)
      write(ioutiunit,*) "tiy1s"
      call WriteArrayReal(tiy1s,size(tiy1s),iunit)
      write(ioutiunit,*) "travis"
      call WriteArrayReal(travis,size(travis),iunit)
      write(ioutiunit,*) "trax_use"
      call WriteArrayReal(trax_use,size(trax_use),iunit)
      write(ioutiunit,*) "tray_use"
      call WriteArrayReal(tray_use,size(tray_use),iunit)
      write(ioutiunit,*) "ttnpg"
      write(ioutiunit,*) ttnpg
      write(ioutiunit,*) "ttotfe"
      write(ioutiunit,*) ttotfe
      write(ioutiunit,*) "ttotjf"
      write(ioutiunit,*) ttotjf
      write(ioutiunit,*) "up"
      call WriteArrayReal(up,size(up),iunit)
      write(ioutiunit,*) "upe"
      call WriteArrayReal(upe,size(upe),iunit)
      write(ioutiunit,*) "upi"
      call WriteArrayReal(upi,size(upi),iunit)
      write(ioutiunit,*) "upxpt"
      call WriteArrayReal(upxpt,size(upxpt),iunit)
      write(ioutiunit,*) "uu"
      call WriteArrayReal(uu,size(uu),iunit)
      write(ioutiunit,*) "uup"
      call WriteArrayReal(uup,size(uup),iunit)
      write(ioutiunit,*) "uz"
      call WriteArrayReal(uz,size(uz),iunit)
      write(ioutiunit,*) "v2"
      call WriteArrayReal(v2,size(v2),iunit)
      write(ioutiunit,*) "v2cb"
      call WriteArrayReal(v2cb,size(v2cb),iunit)
      write(ioutiunit,*) "v2cd"
      call WriteArrayReal(v2cd,size(v2cd),iunit)
      write(ioutiunit,*) "v2ce"
      call WriteArrayReal(v2ce,size(v2ce),iunit)
      write(ioutiunit,*) "v2dd"
      call WriteArrayReal(v2dd,size(v2dd),iunit)
      write(ioutiunit,*) "v2rd"
      call WriteArrayReal(v2rd,size(v2rd),iunit)
      write(ioutiunit,*) "v2xgp"
      call WriteArrayReal(v2xgp,size(v2xgp),iunit)
      write(ioutiunit,*) "ve2cb"
      call WriteArrayReal(ve2cb,size(ve2cb),iunit)
      write(ioutiunit,*) "ve2cd"
      call WriteArrayReal(ve2cd,size(ve2cd),iunit)
      write(ioutiunit,*) "vex"
      call WriteArrayReal(vex,size(vex),iunit)
      write(ioutiunit,*) "vey"
      call WriteArrayReal(vey,size(vey),iunit)
      write(ioutiunit,*) "veycb"
      call WriteArrayReal(veycb,size(veycb),iunit)
      write(ioutiunit,*) "veycp"
      call WriteArrayReal(veycp,size(veycp),iunit)
      write(ioutiunit,*) "visx"
      call WriteArrayReal(visx,size(visx),iunit)
      write(ioutiunit,*) "visxneo"
      call WriteArrayReal(visxneo,size(visxneo),iunit)
      write(ioutiunit,*) "visy"
      call WriteArrayReal(visy,size(visy),iunit)
      write(ioutiunit,*) "visyxpt"
      call WriteArrayReal(visyxpt,size(visyxpt),iunit)
      write(ioutiunit,*) "vsoree"
      call WriteArrayReal(vsoree,size(vsoree),iunit)
      write(ioutiunit,*) "vsoreec"
      call WriteArrayReal(vsoreec,size(vsoreec),iunit)
      write(ioutiunit,*) "vy"
      call WriteArrayReal(vy,size(vy),iunit)
      write(ioutiunit,*) "vy_cft"
      call WriteArrayReal(vy_cft,size(vy_cft),iunit)
      write(ioutiunit,*) "vy_use"
      call WriteArrayReal(vy_use,size(vy_use),iunit)
      write(ioutiunit,*) "vyavis"
      call WriteArrayReal(vyavis,size(vyavis),iunit)
      write(ioutiunit,*) "vycb"
      call WriteArrayReal(vycb,size(vycb),iunit)
      write(ioutiunit,*) "vyce"
      call WriteArrayReal(vyce,size(vyce),iunit)
      write(ioutiunit,*) "vycf"
      call WriteArrayReal(vycf,size(vycf),iunit)
      write(ioutiunit,*) "vycp"
      call WriteArrayReal(vycp,size(vycp),iunit)
      write(ioutiunit,*) "vycr"
      call WriteArrayReal(vycr,size(vycr),iunit)
      write(ioutiunit,*) "vydd"
      call WriteArrayReal(vydd,size(vydd),iunit)
      write(ioutiunit,*) "vygp"
      call WriteArrayReal(vygp,size(vygp),iunit)
      write(ioutiunit,*) "vyhxpt"
      call WriteArrayReal(vyhxpt,size(vyhxpt),iunit)
      write(ioutiunit,*) "vyrd"
      call WriteArrayReal(vyrd,size(vyrd),iunit)
      write(ioutiunit,*) "vytan"
      call WriteArrayReal(vytan,size(vytan),iunit)
      write(ioutiunit,*) "vyte_cft"
      call WriteArrayReal(vyte_cft,size(vyte_cft),iunit)
      write(ioutiunit,*) "vyti_cft"
      call WriteArrayReal(vyti_cft,size(vyti_cft),iunit)
      write(ioutiunit,*) "vyvxpt"
      call WriteArrayReal(vyvxpt,size(vyvxpt),iunit)
      write(ioutiunit,*) "w"
      call WriteArrayReal(w,size(w),iunit)
      write(ioutiunit,*) "w0"
      call WriteArrayReal(w0,size(w0),iunit)
      write(ioutiunit,*) "w1"
      call WriteArrayReal(w1,size(w1),iunit)
      write(ioutiunit,*) "w2"
      call WriteArrayReal(w2,size(w2),iunit)
      write(ioutiunit,*) "w3"
      call WriteArrayReal(w3,size(w3),iunit)
      write(ioutiunit,*) "wjdote"
      call WriteArrayReal(wjdote,size(wjdote),iunit)
      write(ioutiunit,*) "xcnearlb"
      write(ioutiunit,*) xcnearlb
      write(ioutiunit,*) "xcnearrb"
      write(ioutiunit,*) xcnearrb
      write(ioutiunit,*) "zcoef"
      write(ioutiunit,*) zcoef
      write(ioutiunit,*) "zeff"
      call WriteArrayReal(zeff,size(zeff),iunit)
      write(ioutiunit,*) "znot"
      call WriteArrayReal(znot,size(znot),iunit)

      close(iunit)
c$ omp end  parallel
      end subroutine DebugHelper
