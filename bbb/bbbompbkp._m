c!include "bbb.h"
c!include "../com/com.h"
c!include "../mppl.h"
c!include "../sptodp.h"
      subroutine jac_calc_para (neq, t, yl, yldot00, ml, mu, wk,
     .                     nnzmx, jac, ja, ia)

c ... Calculate Jacobian matrix (derivatives with respect to each
c     dependent variable of the right-hand side of each rate equation).
c     Lower and upper bandwidths are used to select for computation
c     only those Jacobian elements that may be nonzero.
c     Estimates of Jacobian elements are computed by finite differences.
c     The Jacobian is stored in compressed sparse row format.

      implicit none

c ... Input arguments:
      integer neq      # total number of equations (all grid points)
      real t           # physical time
      real yl(*)       # dependent variables
      real yldot00(neq+2) # right-hand sides evaluated at yl
      integer ml, mu   # lower and upper bandwidths
      integer nnzmx    # maximum number of nonzeros in Jacobian


c ... Work-array argument:
      real wk(neq)     # work space available to this subroutine
      integer,allocatable :: iJacConstructor(:,:)
      real,allocatable:: rJacConstructor(:,:)


c ... Output arguments:
      real jac(nnzmx)     # nonzero Jacobian elements
      integer ja(nnzmx)   # col indices of nonzero Jacobian elements
      integer ia(neq+1)   # pointers to beginning of each row in jac,ja

c ... Common blocks:
      Use(Dim)                     # nx,ny,
                                   # nusp[for fnorm not used here]
      Use(Timing)                  # istimingon,ttjstor,ttotjf,ttimpjf
      Use(Math_problem_size)       # neqmx,numvar
      Use(Grid)                    # ngrid,ig,ijac,ijactot
      Use(Indexes)                 # igyl,iseqalg
      Use(Variable_perturbation)   # del,dylconst
      Use(Jacobian_csc)            # rcsc,jcsc,icsc,yldot_pert
      Use(Ynorm)                   # suscal,sfscal
      Use(UEpar)                   # isphion,isnewpot,svrpkg,isbcwdt
      Use(Model_choice)            # iondenseqn
      Use(Imprad)                  # isimpon
      Use(Bcond)                   # isextrnpf,isextrtpf,isextrngc,
                                   # isextrnw,isextrtw
      Use(Parallv)                 # nxg,nyg
      Use(Time_dep_nwt)            # nufak,dtreal,ylodt,dtuse
      Use(Selec)                   # yinc
      Use(Preconditioning)         #lenpfac
      Use(OmpOptions)
c ... Functions
      logical tstguardc
      real(Size4) gettime
cc      real(Size4) ranf

c ... Local variables:
      integer i,Nsize,R,thread
      integer,parameter:: Nthreadmax=256
      integer,allocatable::nnz(:),nnzcum(:)
      integer,allocatable,dimension(:,:) ::iJacCol,iJacRow
      real,allocatable,dimension(:,:) ::rJacElem
      integer ivmax(Nthreadmax),ivmin(Nthreadmax)
      real(Size4) sec4, tsjstor, tsimpjf, dtimpjf,time0,time1,TimeBuild
      real(Size4) TimeReduce
      INTEGER :: NTHREADS, TID, OMP_GET_NUM_THREADS, OMP_GET_THREAD_NUM
      integer:: ith,iv,neq_,nnzmxperthread
      character(len = 80) ::  filename
cJG First we get the number of threads
c$omp PARALLEL PRIVATE(TID)
      TID = OMP_GET_THREAD_NUM()
      IF (TID .EQ. 0) THEN
        NTHREADS = OMP_GET_NUM_THREADS()
      END IF
c$omp END PARALLEL

cJG Then we obtain the range of iv index per thread
       neq_=neq
       Nsize=neq_/Nthreads
       R=MOD(neq_, Nthreads)
       if (Nthreads.gt.1) then
            if (R.eq.0) then
                do i=1,Nthreads
                    ivmin(i)=1+Nsize*(i-1)
                    ivmax(i)=Nsize*i
                enddo
            else
                do i=1,Nthreads-1
                ivmin(i)=1+Nsize*(i-1)
                ivmax(i)=Nsize*i
                enddo
                ivmin(Nthreads)=ivmax(Nthreads-1)+1
                ivmax(Nthreads)=neq_
            endif
        else
            ivmin(Nthreads)=1
            ivmax(Nthreads)=neq_
        endif


        if (OMPDebug.gt.0) then
        write(iout*,*)' Ivmin,Ivmax:'
            do i=1,Nthreads
                write(iout*,*) ivmin(i),ivmax(i)
            enddo
        endif


      if (Nthreads.gt.1) then
      nnzmxperthread=ceiling(real(nnzmx)/real(Nthreads-1))
      else
      nnzmxperthread=nnzmx
      endif
      write(iout*,*) 'Allocating size:',neq,nnzmxperthread,nnzmxperthread*8*Nthreads/1e9,'Gb'
      allocate(iJacRow(neq,Nthreads))
      allocate(iJacCol(nnzmxperthread,Nthreads))
      allocate(rJacElem(nnzmxperthread,Nthreads))
      allocate(nnz(Nthreads))
      allocate(nnzcum(Nthreads))
      nnz(1:Nthreads)=-1
      nnzcum(1:Nthreads)=-1
      write(iout*,*) 'Allocatation done....'
      iJacCol(1:nnzmxperthread,1:Nthreads)=0
      write(iout*,*) 'Inialization iJacCol done....'
      rJacElem(1:nnzmxperthread,1:Nthreads)=0.0
      write(iout*,*) 'Inialization rJacElem done....'
      iJacRow(1:neq,1:Nthreads)=0
      write(iout*,*) 'Inialization iJacRow done....'
      nnzmxperthread=nnzmxperthread



ccc      save

c ... Get initial value of system cpu timer.
      if (istimingon .eq. 1) tsjstor = gettime(sec4)

c ... Pause from BASIS if a ctrl_c is typed
      call ruthere

c ... Count Jacobian evaluations, both for total and for this case
      ijactot = ijactot + 1
      ijac(ig) = ijac(ig) + 1
      if (svrpkg.eq.'nksol') write(iout*,*) ' Updating Jacobian, npe =  ',
     .                                                          ijac(ig)

c ... Set up diagnostic arrays for debugging
      do iv = 1, neq
        yldot_unpt(iv) = yldot00(iv)  # for diagnostic only
        yldot_pert(iv) = 0.
      enddo

c############################################
c ... Begin loop over dependent variables.
c############################################
cJG Running with  openmp target requires to have -fopen flag and foffload flag added to both gfortran and gcc.
c JG Let test it with a gpu (maybe summit 1 at GA?)
      write(iout*,*) 'OMP construction of Jacobian with Nthreads=',Nthreads
      TimeBuild=gettime(sec4)
        call OMPJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml, mu,wk,
     .                      iJacCol,rJacElem,iJacRow,nnz,nnzmxperthread,
     .                      nthreads)

c##############################################################
      TimeBuild=gettime(sec4)-TimeBuild
      write(iout*,*)'Time to build jac:',TimeBuild
      if (DebugTime.gt.0) then
      write(iout*,*)'Time in var loop calc_jac:',gettime(sec4)-tsjstor
      endif
c #reduction of jacobian data into single vector
      TimeReduce=gettime(sec4)
      nnzcum(1)=nnz(1)-1

      do ith=2,Nthreads
        nnzcum(ith)=nnzcum(ith-1)+nnz(ith)-1
      enddo
      if (OMPDebug.gt.0) then
      write(iout*,*) 'nnzcum=',nnzcum
      endif
      if (nnzcum(Nthreads).gt.nnzmx) then
        write(iout*,*)'Houston we have a problem with nnz...'
      endif


        jcsc(ivmin(1):ivmax(1))= iJacRow(ivmin(1):ivmax(1),1)
      do ith=2,Nthreads
        jcsc(ivmin(ith):ivmax(ith))= iJacRow(ivmin(ith):ivmax(ith),ith)
     .                                +nnzcum(ith-1)
      enddo

      rcsc(1:nnz(1)-1)= rJacElem(1:nnz(1)-1,1)
      icsc(1:nnz(1)-1)= iJacCol(1:nnz(1)-1,1)
      do ith=2,Nthreads
       rcsc(nnzcum(ith-1)+1:nnzcum(ith))=
     .                            rJacElem(1:nnz(ith)-1,ith)
       icsc(nnzcum(ith-1)+1:nnzcum(ith))=
     .                            iJacCol(1:nnz(ith)-1,ith)
      enddo






      jcsc(neq+1) = nnzcum(Nthreads)+1


      TimeReduce=gettime(sec4)-TimeReduce
      write(iout*,*)'**** Time to reduce jac:',TimeReduce
      deallocate(iJacRow)
      deallocate(iJacCol)
      deallocate(rJacElem)
      deallocate(nnz)
      deallocate(nnzcum)

c ... Convert Jacobian from compressed sparse column to compressed
c     sparse row format.
      time1=gettime(sec4)

      write(iout*,*) 'size rcsc=',size(rcsc),size(jac),size(icsc),size(ja),size(jcsc),size(ia)
      call csrcsc (neq, 1, 1, rcsc, icsc, jcsc, jac, ja, ia)
      if (DebugTime.gt.0) then
      write(iout*,*)'Time to convert jac:',gettime(sec4)-time1
      endif


cccc ... If desired, calculate Jacobian elements for ion continuity
cccc     equation by using INEL routines, and combine elements with
cccc     those calculated above.
ccc      if (iondenseqn .eq. "inel") then
ccc         call iondens2 (neq, nnzmx, jac, ja, ia, rcsc, icsc, jcsc)
ccc      endif

cccc ... If necessary, calculate Jacobian elements for rows corresponding
cccc     to impurity-density equations (for cells other than guard cells),
cccc     and combine elements with those calculated above.
ccc      if (isimpon .eq. 3 .or. isimpon .eq. 4) then
ccc         if (istimingon .eq. 1) tsimpjf = gettime(sec4)
ccc         call impdens2 (neq, nnzmx, jac, ja, ia, rcsc, icsc, jcsc)
ccc         if (istimingon .eq. 1) then
ccc            dtimpjf = gettime(sec4) - tsimpjf
ccc            ttimpjf = ttimpjf + dtimpjf
ccc            ttotjf = ttotjf + dtimpjf
ccc         endif
ccc      endif

      if (istimingon .eq. 1) ttjstor = ttjstor + gettime(sec4) - tsjstor
      if (DebugTime.gt.0) then
      write(iout*,*)'Time in calc_jac:',gettime(sec4)-tsjstor
      endif
      return
      end subroutine

c-----------------------------------------------------------------------
      subroutine OMPJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml,
     .  mu,wk,iJacCol,rJacElem,iJacRow,nnz,nnzmx,
     .                      nthreads)
        implicit none
        Use(OmpOptions)
        Use(OmpCopybbb)
c        Use(OmpCopygrd)
        Use(OmpCopycom)
c        Use(OmpCopyflx)
        Use(OmpCopyapi)

        Use(Compla)
        Use(Dim)
        Use(Selec)
        Use(Math_problem_size)
        Use(MCN_dim)
        Use(Indices_domain_dcl)
        Use(Reduced_ion_interface)
          integer,intent(in):: nnzmx,nthreads
          integer,intent(inout)::nnz(Nthreads)
          integer,intent(in):: ivmin(Nthreads),ivmax(Nthreads)      # index equation
          integer,intent(in):: neq      # total number of equations (all grid points)
          real,intent(in):: t           # physical time
          real ::yl(*)       # dependent variables
          real,intent(inout) :: wk(neq)
          real ::wkcopy(neq)
          real::ylcopy(neq+2)
       integer,intent(inout)::iJacCol(nnzmx,nthreads)
       integer,intent(inout):: iJacRow(neq,nthreads)
          real,intent(inout):: rJacElem(nnzmx,nthreads)
       integer ::iJacColCopy(nnzmx)
       integer :: iJacRowCopy(neq)
          real :: rJacElemCopy(nnzmx)
          real,intent(in) ::yldot00(neq+2) # right-hand sides evaluated at yl
          integer,intent(in):: ml, mu   # lower and upper bandwidths

c ... Work-array argument:


          integer:: ith,omp_get_thread_num,tid,nnzlocal,ithcopy




      if (OMPDebug.gt.0) then
      write(iout*,*) '**** Copying data....'
      endif


      call OmpCopyPointerbbb
      call OmpCopyScalarbbb
      call OmpCopyPointercom
      call OmpCopyScalarcom
c      call OmpCopyPointergrd
c      call OmpCopyScalargrd
      call OmpCopyPointerapi
      call OmpCopyScalarapi
c      call OmpCopyPointerflx
c      call OmpCopyScalarflx

      iJacColCopy(1:nnzmx)=0
      rJacElemCopy(1:nnzmx)=0.0
      iJacRowCopy(1:neq)=0
      ylcopy(1:neq+2)=yl(1:neq+2) # a very barbarian use of yl(neq+1) is implemented as a switch in pandf... Error-prone!
      wkcopy(1:neq)=wk(1:neq)

      if (OMPDebug.gt.0) then
      write(iout*,*) '**** Starting parallel loop....'
      endif
      tid=-1
       nnzlocal=-10000
      write(iout*,*) 'nnzmx=',nnzmx
c$omp parallel do default(shared)
c$omp& firstprivate(ithcopy,ivmin,ivmax,tid,nnzlocal,ylcopy,wkcopy,ml,mu,yldot00,t,neq)
c$omp& firstprivate(nnzmx,nthreads)
c$omp& firstprivate(iJacRowCopy)
c$omp& shared(nnz,iJacCol,rJacElem,iJacRow)
c$omp& firstprivate(iJacColCopy)
c$omp& firstprivate(rJacElemCopy)
        do ith=1,Nthreads !ith from 1 to Nthread, tid from 0 to Nthread-1
        tid=omp_get_thread_num()
        ithcopy=ith
        write(iout*,*) '#OMP: Thread id:',tid,' <-> ith:',ithcopy
      call LocalJacBuilder(ivmin(ithcopy),ivmax(ithcopy),neq, t, ylcopy,yldot00,
     . ml,mu,wkcopy,iJacColcopy,rJacElemcopy,iJacRowcopy,ithcopy,nnzlocal,
     . nnzmx,nthreads)
      write(iout*,*) '#,',tid,' nzlocal:',nnzlocal
c$omp critical
      iJacCol(1:nnzlocal,ithcopy)=iJacColCopy(1:nnzlocal)
      rJacElem(1:nnzlocal,ithcopy)=rJacElemCopy(1:nnzlocal)
      iJacRow(1:neq,ithcopy)=iJacRowCopy(1:neq)
      nnz(ithcopy)=nnzlocal
c$omp end critical

c##############################################################
c      enddo             # end of main loop over yl variables
      enddo
c$omp END PARALLEL DO
      if (OMPDebug.gt.0) then
      write(iout*,*) '**** End of parallel loop....'
      endif



      end subroutine OMPJacBuilder

c ----------------------------------------------------------------------
      subroutine LocalJacBuilder(ivmin,ivmax,neq, t, yl,yldot00, ml, mu, wk,
     .                      iJacCol,rJacElem,iJacRow,ith,nnz,nnzmx,
     .                      nthreads)


c ... Calculate Jacobian matrix (derivatives with respect to each
c     dependent variable of the right-hand side of each rate equation).
c     Lower and upper bandwidths are used to select for computation
c     only those Jacobian elements that may be nonzero.
c     Estimates of Jacobian elements are computed by finite differences.
c     The Jacobian is stored in compressed sparse row format.

      implicit none

      integer,intent(in):: ith,nnzmx,nthreads
      integer,intent(inout)::nnz
      integer,intent(in):: ivmin,ivmax      # index equation
      integer,intent(in):: neq      # total number of equations (all grid points)
      real,intent(in):: t           # physical time
      real ::yl(*)       # dependent variables
      integer,intent(inout)::iJacCol(nnzmx),iJacRow(neq)
      real,intent(inout):: rJacElem(nnzmx)
      real,intent(in) ::yldot00(neq+2) # right-hand sides evaluated at yl
      integer,intent(in):: ml, mu   # lower and upper bandwidths

c ... Work-array argument:
      real,intent(inout) :: wk(neq)     # work space available to this subroutine
c ... Common blocks:
      Use(Dim)                     # nx,ny
      Use(Timing)                  # istimingon,ttjstor,ttotjf,ttimpjf
      Use(Math_problem_size)       # neqmx,numvar
      Use(Grid)                    # ngrid,ig,ijac,ijactot
      Use(Indexes)                 # igyl,iseqalg
      Use(Variable_perturbation)   # del,dylconst
      Use(Jacobian_clipping)       # jaccliplim,istopjac,irstop,icstop
      Use(Ynorm)                   # suscal,sfscal
      Use(UEpar)                   # isphion,isnewpot,svrpkg,isbcwdt
      Use(Model_choice)            # iondenseqn
      Use(Imprad)                  # isimpon
      Use(Bcond)                   # isextrnpf,isextrtpf,isextrngc,
                                   # isextrnw,isextrtw
      Use(Parallv)                 # nxg,nyg
      Use(Time_dep_nwt)            # nufak,dtreal,ylodt,dtuse
      Use(Selec)                   # yinc
      Use(Preconditioning)         #lenpfac
      Use(Jacobian_csc)
      Use(OmpOptions)
      Use(Compla)
c ... Functions:
      logical ::tstguardc
      real(Size4) gettime
cc      real(Size4) ranf

c ... Local variables:
      integer :: ii, iv, jv,ii1, ii2, xc, yc, ix, iy

      real ::yold, dyl, jacelem
      real(Size4) sec4, tsjstor, tsimpjf, dtimpjf,time0
      integer:: ivcount
      integer:: omp_get_thread_num,tid
c       time0=gettime(sec4) #here



ccc ... Only perturb variables that are being solved for (for Daspk option)
ccc      if (iseqon(iv) .eq. 0) goto 18

c ... Set beginning and ending indices of right-hand sides that might be
c     perturbed.
       tid=omp_get_thread_num()
         nnz=1
         ivcount=0
        do iv=ivmin,ivmax
           ivcount=ivcount+1
         ii1 = max(iv-mu, 1)
         ii2 = min(iv+ml, neq)
c ... Reset range if this is a potential perturbation with isnewpot=1
ccc         if (isphion*isnewpot.eq.1 .and. mod(iv,numvar).eq.0) then
         if (isphion*isnewpot.eq.1) then
            ii1 = max(iv-4*numvar*nx, 1)      # 3*nx may be excessive
            ii2 = min(iv+4*numvar*nx, neq)    # 3*nx may be excessive
         endif
c ... Reset range if extrapolation boundary conditions are used
         if (isextrnpf+isextrtpf+isextrngc+isextrnw+isextrtw.gt.0) then
            ii1 = max(iv-2*numvar*(nx+3), 1)      # guess to include extrap. bc
            ii2 = min(iv+2*numvar*(nx+3), neq)    # guess to include extrap. bc
         endif

c ... Initialize all of those right-hand sides to their unperturbed
c     values.

         do ii = ii1, ii2   # a) below wk is reset, but only over limited range
            wk(ii) = yldot00(ii)
         enddo

c ... Set spatial-location indices for this dependent variable.
         xc = igyl(iv,1)
         yc = igyl(iv,2)

c ... Save value of dependent variable, then perturb it.
c     The perturbation to the variable is proportional to parameter
c     del and to a measure of the size of the variable.  That measure
c     increases with the absolute value of the variable if it exceeds
c     the typical size given by dylconst/suscal but can never be less
c     than that typical size.
         yold = yl(iv)
         dyl = delperturb * (abs(yold) + dylconst / suscal(iv))
         yl(iv) = yold + dyl
c ... Calculate right-hand sides near location of perturbed variable.
ccc         call convsr_vo (xc, yc, yl)  # test new convsr placement
ccc         call convsr_aux (xc, yc, yl) # test new convsr placement

         call pandf1 (xc, yc, iv, neq, t, yl, wk)


ccc         yl(iv) = yold - dyl    # for 2nd order Jac
ccc         call pandf1 (xc, yc, iv, neq, t, yl, yldot0) # for 2nd order Jac
c ... Calculate possibly nonzero Jacobian elements for this variable,
c     and store nonzero elements in compressed sparse column format.
         iJacRow(iv) = nnz      # sets index for first Jac. elem. of var. iv

c############### loop ii

         do ii = ii1, ii2

c dtuse,iseqalg,jacelem,idxphi,dtphi,sfscal,jaccliplim,nnzmx

            jacelem = (wk(ii) - yldot00(ii)) / dyl
ccc            jacelem = (wk/(ii) - yldot0(ii)) / (2*dyl)  # for 2nd order Jac
c ...  Add diagonal 1/dt for nksol
      if (((svrpkg.eq."nksol") .or. (svrpkg.eq."petsc")) .and. iv.eq.ii)
     .then
              if (iseqalg(iv)*(1-isbcwdt).eq.0) then
                jacelem = jacelem - 1/dtuse(iv)
              endif
              ix = igyl(iv,1)
              iy = igyl(iv,2)
              if (idxphi(ix,iy)==iv .and. dtphi<1e10) then #selects phi eqn
                jacelem = jacelem - 1/dtphi
              endif
c              write(iout*,*) 'iv,jacelem after dt:',jacelem
       endif

c ...  Add a pseudo timestep to the diagonal ## if eqn is not algebraic
       if (svrpkg .ne. "cvode" .and. nufak .gt. 0) then
               if (iv.eq.ii .and. yl(neq+1).eq.1)
     .          jacelem = jacelem - nufak  #omit .and. iseqalg(iv).eq.0)
cc     .                   jacelem = jacelem - nufak*suscal(iv)/sfscal(iv)
               endif
c        write(iout*,'(a,i3,i5,i5,e16.6)') '#',ith,iv,ii,jacelem
        if (abs(jacelem*sfscal(iv)) .gt. jaccliplim) then

               if (nnz .gt. nnzmx) then
                  write(iout*,*) nnz,nnzmx
                  write(ioutSTDOUT,*)
     .             'ith',ith,'*** jac_calc -- More storage needed for Jacobian.',
     .             ' Storage exceeded at (i,j) = (',ii,',',iv,').',
     .             ' Increase lenpfac.'
	              call xerrab("")
               endif
cc               if (rdoff.ne.0.e0) jacelem=jacelem*(1.0e0+ranf()*rdoff)
cJG We need to modify the way the jacobian elements are counted for since this is a 'linear' implementation.
cJG We cannot use the do linear construct for nnz here because there is an if condition on nnz
cWe create an array to store value of jacelem and ii per value of iv then we reduce it after the target implementation
cJG That way, we avoid having to deal with synchronization and atomic construct which are time consuming
cJG(under the assumoption that we have way enough memory (>10Gb), why bother for a single array?)
cJG               rcsc(nnz) = jacelem
cJG               icsc(nnz) = ii
             iJacCol(nnz)=ii
            rJacElem(nnz)=jacelem

        if (OMPDebug.gt.0) then
c      write(iout*,'(a,i3,a,i7,i7,i7, E16.6,E16.6,E16.6)') '#', ith,' : ',iv,nnz,
c     .ii,jacelem,wk(ii),yldot00(ii)
        endif


            nnz = nnz + 1

         endif

             if (istopjac.gt.0 .and. ii.eq.irstop .and. iv.eq.icstop) then
ccc               yldot_pert(ii) = wk(ii)      # for diagnostic only
                   if (istopjac == 2) then
                     yl(iv) = yold
                     call pandf1 (xc, yc, iv, neq, t, yl, wk)
                   endif
ccc               call convsr_vo (xc, yc, yl)  # was one call to convsr
ccc               call convsr_aux (xc, yc, yl)
                   call remark("***** non-zero jac_elem at irstop,icstop")
                  write(iout*,*) 'irstop = ', irstop, ', icstop = ', icstop
                   call xerrab("")
             endif
         enddo  # end of ii loop over equations


c ... Restore dependent variable and plasma variables near its location.
         yl(iv) = yold
ccc         call convsr_vo (xc, yc, yl)  # was one call to convsr
ccc         call convsr_aux (xc, yc, yl)
         call pandf1 (xc, yc, iv, neq, t, yl, wk)
         yldot_pert(1:neq)=wk(1:neq)
ccc 18   continue
c...  If this is the last variable before jumping to new cell, reset pandf
ccc 18   continue
cJG1 why do we need to reset?????
c...  If this is the last variable before jumping to new cell, reset pandf
         if (mod(iv,numvar).eq.0 .and. isjacreset.ge.1) then
c         call DebugHelper('dump00.txt')
           call pandf1 (xc, yc, iv, neq, t, yl, wk)
         endif
ccc$omp critical
         do ii=ii1, ii2
         if (yldot_pert(ii).ne.wk(ii)) then

      write(iout*,'(a,i3,a,i5,e20.12,e20.12)') ' ith:',ith,' *** wk modified on second call at ii=',
     . ii,yldot_pert(ii),wk(ii)

cc         call DebugHelper('dump11.txt')
c         write(iout*,*) 'dumped'
         stop

         endif

         enddo
cccc$omp end critical
cJG      yldot_pert(iv)=gettime(sec4)-time0
      enddo
c ... End loop over dependent variables and finish Jacobian storage.
      end subroutine LocalJacBuilder


            SUBROUTINE scopy(N,SX,INCX,SY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
        INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
        REAL SX(*),SY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
        INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
        INTRINSIC mod
*     ..
       IF (n.LE.0) RETURN
       IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
              m = mod(n,7)
              IF (m.NE.0) THEN
                 DO i = 1,m
                    sy(i) = sx(i)
                 END DO
                 IF (n.LT.7) RETURN
              END IF
              mp1 = m + 1
              DO i = mp1,n,7
                 sy(i) = sx(i)
                 sy(i+1) = sx(i+1)
                 sy(i+2) = sx(i+2)
                 sy(i+3) = sx(i+3)
                 sy(i+4) = sx(i+4)
                 sy(i+5) = sx(i+5)
                 sy(i+6) = sx(i+6)
              END DO
           ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
          ix = 1
          iy = 1
          IF (incx.LT.0) ix = (-n+1)*incx + 1
          IF (incy.LT.0) iy = (-n+1)*incy + 1
          DO i = 1,n
             sy(iy) = sx(ix)
             ix = ix + incx
             iy = iy + incy
          END DO
       END IF
       RETURN
       END


       SUBROUTINE saxpy(N,SA,SX,INCX,SY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
       REAL SA
       INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
       REAL SX(*),SY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
       INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
       INTRINSIC mod
*     ..
       IF (n.LE.0) RETURN
       IF (sa.EQ.0.0) RETURN
       IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
          m = mod(n,4)
          IF (m.NE.0) THEN
             DO i = 1,m
                sy(i) = sy(i) + sa*sx(i)
             END DO
          END IF
          IF (n.LT.4) RETURN
          mp1 = m + 1
          DO i = mp1,n,4
             sy(i) = sy(i) + sa*sx(i)
             sy(i+1) = sy(i+1) + sa*sx(i+1)
             sy(i+2) = sy(i+2) + sa*sx(i+2)
             sy(i+3) = sy(i+3) + sa*sx(i+3)
          END DO
       ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
          ix = 1
          iy = 1
          IF (incx.LT.0) ix = (-n+1)*incx + 1
          IF (incy.LT.0) iy = (-n+1)*incy + 1
          DO i = 1,n
           sy(iy) = sy(iy) + sa*sx(ix)
           ix = ix + incx
           iy = iy + incy
          END DO
       END IF
       RETURN
       END

             subroutine sgefa(a,lda,n,ipvt,info)
      integer lda,n,ipvt(1),info
      real a(lda,1)
c
c     sgefa factors a real matrix by gaussian elimination.
c
c     sgefa is usually called by sgeco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c     (time for sgeco) = (1 + 9/n)*(time for sgefa) .
c
c     on entry
c
c        a       real(lda, n)
c                the matrix to be factored.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       an upper triangular matrix and the multipliers
c                which were used to obtain it.
c                the factorization can be written  a = l*u  where
c                l  is a product of permutation and unit lower
c                triangular matrices and  u  is upper triangular.
c
c        ipvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if  u(k,k) .eq. 0.0 .  this is not an error
c                     condition for this subroutine, but it does
c                     indicate that sgesl or sgedi will divide by zero
c                     if called.  use  rcond  in sgeco for a reliable
c                     indication of singularity.
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas saxpy,sscal,isamax
c
c     internal variables
c
      real t
      integer isamax,j,k,kp1,l,nm1
c
c
c     gaussian elimination with partial pivoting
c
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
c
c        find l = pivot index
c
         l = isamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
c
c        zero pivot implies this column already triangularized
c
         if (a(l,k) .eq. 0.0e0) go to 40
c
c           interchange if necessary
c
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
c
c           compute multipliers
c
            t = -1.0e0/a(k,k)
            call sscal(n-k,t,a(k+1,k),1)
c
c           row elimination with column indexing
c
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20
                  a(l,j) = a(k,j)
                  a(k,j) = t
   20          continue
               call saxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue
   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0e0) info = n
      return
      end

      subroutine WriteArrayReal(array,s,iu)
      implicit none
      real:: array(*)
      integer:: i,s,iu
      do i=1,s
      write(ioutiu,*) array(i)
      enddo
      end subroutine WriteArrayReal

      subroutine WriteArrayInteger(array,s,iu)
      implicit none
      integer:: array(*)
      integer:: i,s,iu
      do i=1,s
      write(ioutiu,*) array(i)
      enddo
      end subroutine WriteArrayInteger

      subroutine DebugHelper(FileName)
      implicit none
      integer,parameter:: iunit=777
      character(len = *) ::  filename

      Use(Bcond)
      Use(Cfric)
      Use(Coefeq)
      Use(Comflo)
      Use(Comgeo)
      Use(Compla)
      Use(Comtra)
      Use(Conduc)
      Use(Dim)
      Use(Gradients)
      Use(Imprad)
      Use(Locflux)
      Use(MCN_sources)
      Use(PNC_params)
      Use(Rhsides)
      Use(Save_terms)
      Use(Selec)
      Use(Time_dep_nwt)
      Use(Timing)
      Use(UEpar)
      Use(Wkspace)
c$ omp  parallel default(firstprivate)
      open (unit = iunit, file = trim(filename))
      write(ioutiunit,*) "alfneo"
      call WriteArrayReal(alfneo,size(alfneo),iunit)
      write(ioutiunit,*) "betap"
      call WriteArrayReal(betap,size(betap),iunit)
      write(ioutiunit,*) "cfneut"
      write(ioutiunit,*) cfneut
      write(ioutiunit,*) "cfneutdiv"
      write(ioutiunit,*) cfneutdiv
      write(ioutiunit,*) "cfvcsx"
      call WriteArrayReal(cfvcsx,size(cfvcsx),iunit)
      write(ioutiunit,*) "cfvcsy"
      call WriteArrayReal(cfvcsy,size(cfvcsy),iunit)
      write(ioutiunit,*) "cfvgpx"
      call WriteArrayReal(cfvgpx,size(cfvgpx),iunit)
      write(ioutiunit,*) "cfvgpy"
      call WriteArrayReal(cfvgpy,size(cfvgpy),iunit)
      write(ioutiunit,*) "cmneut"
      write(ioutiunit,*) cmneut
      write(ioutiunit,*) "cmneutdiv"
      write(ioutiunit,*) cmneutdiv
      write(ioutiunit,*) "coef1"
      write(ioutiunit,*) coef1
      write(ioutiunit,*) "coll_fe"
      call WriteArrayReal(coll_fe,size(coll_fe),iunit)
      write(ioutiunit,*) "coll_fi"
      call WriteArrayReal(coll_fi,size(coll_fi),iunit)
      write(ioutiunit,*) "conx"
      call WriteArrayReal(conx,size(conx),iunit)
      write(ioutiunit,*) "conxe"
      call WriteArrayReal(conxe,size(conxe),iunit)
      write(ioutiunit,*) "conxi"
      call WriteArrayReal(conxi,size(conxi),iunit)
      write(ioutiunit,*) "cony"
      call WriteArrayReal(cony,size(cony),iunit)
      write(ioutiunit,*) "conye"
      call WriteArrayReal(conye,size(conye),iunit)
      write(ioutiunit,*) "conyi"
      call WriteArrayReal(conyi,size(conyi),iunit)
      write(ioutiunit,*) "cs"
      write(ioutiunit,*) cs
      write(ioutiunit,*) "csh"
      write(ioutiunit,*) csh
      write(ioutiunit,*) "ctaue"
      write(ioutiunit,*) ctaue
      write(ioutiunit,*) "ctaui"
      write(ioutiunit,*) ctaui
      write(ioutiunit,*) "dclass_e"
      call WriteArrayReal(dclass_e,size(dclass_e),iunit)
      write(ioutiunit,*) "dclass_i"
      call WriteArrayReal(dclass_i,size(dclass_i),iunit)
      write(ioutiunit,*) "dif2_use"
      call WriteArrayReal(dif2_use,size(dif2_use),iunit)
      write(ioutiunit,*) "dif_use"
      call WriteArrayReal(dif_use,size(dif_use),iunit)
      write(ioutiunit,*) "diffusivwrk"
      call WriteArrayReal(diffusivwrk,size(diffusivwrk),iunit)
      write(ioutiunit,*) "difp_use"
      call WriteArrayReal(difp_use,size(difp_use),iunit)
      write(ioutiunit,*) "dp1"
      write(ioutiunit,*) dp1
      write(ioutiunit,*) "dtold"
      write(ioutiunit,*) dtold
      write(ioutiunit,*) "dtreal"
      write(ioutiunit,*) dtreal
      write(ioutiunit,*) "dutm_use"
      call WriteArrayReal(dutm_use,size(dutm_use),iunit)
      write(ioutiunit,*) "eeli"
      call WriteArrayReal(eeli,size(eeli),iunit)
      write(ioutiunit,*) "eqp"
      call WriteArrayReal(eqp,size(eqp),iunit)
      write(ioutiunit,*) "eqpg"
      call WriteArrayReal(eqpg,size(eqpg),iunit)
      write(ioutiunit,*) "erliz"
      call WriteArrayReal(erliz,size(erliz),iunit)
      write(ioutiunit,*) "erlrc"
      call WriteArrayReal(erlrc,size(erlrc),iunit)
      write(ioutiunit,*) "eta1"
      call WriteArrayReal(eta1,size(eta1),iunit)
      write(ioutiunit,*) "ex"
      call WriteArrayReal(ex,size(ex),iunit)
      write(ioutiunit,*) "ey"
      call WriteArrayReal(ey,size(ey),iunit)
      write(ioutiunit,*) "fcdif"
      write(ioutiunit,*) fcdif
      write(ioutiunit,*) "fdiaxlb"
      call WriteArrayReal(fdiaxlb,size(fdiaxlb),iunit)
      write(ioutiunit,*) "fdiaxrb"
      call WriteArrayReal(fdiaxrb,size(fdiaxrb),iunit)
      write(ioutiunit,*) "feex"
      call WriteArrayReal(feex,size(feex),iunit)
      write(ioutiunit,*) "feexy"
      call WriteArrayReal(feexy,size(feexy),iunit)
      write(ioutiunit,*) "feey"
      call WriteArrayReal(feey,size(feey),iunit)
      write(ioutiunit,*) "feey4ord"
      call WriteArrayReal(feey4ord,size(feey4ord),iunit)
      write(ioutiunit,*) "feeycbo"
      call WriteArrayReal(feeycbo,size(feeycbo),iunit)
      write(ioutiunit,*) "feix"
      call WriteArrayReal(feix,size(feix),iunit)
      write(ioutiunit,*) "feixy"
      call WriteArrayReal(feixy,size(feixy),iunit)
      write(ioutiunit,*) "feiy"
      call WriteArrayReal(feiy,size(feiy),iunit)
      write(ioutiunit,*) "feiy4ord"
      call WriteArrayReal(feiy4ord,size(feiy4ord),iunit)
      write(ioutiunit,*) "feiycbo"
      call WriteArrayReal(feiycbo,size(feiycbo),iunit)
      write(ioutiunit,*) "flox"
      call WriteArrayReal(flox,size(flox),iunit)
      write(ioutiunit,*) "floxe"
      call WriteArrayReal(floxe,size(floxe),iunit)
      write(ioutiunit,*) "floxebgt"
      call WriteArrayReal(floxebgt,size(floxebgt),iunit)
      write(ioutiunit,*) "floxi"
      call WriteArrayReal(floxi,size(floxi),iunit)
      write(ioutiunit,*) "floxibgt"
      call WriteArrayReal(floxibgt,size(floxibgt),iunit)
      write(ioutiunit,*) "floy"
      call WriteArrayReal(floy,size(floy),iunit)
      write(ioutiunit,*) "floye"
      call WriteArrayReal(floye,size(floye),iunit)
      write(ioutiunit,*) "floyi"
      call WriteArrayReal(floyi,size(floyi),iunit)
      write(ioutiunit,*) "fmihxpt"
      call WriteArrayReal(fmihxpt,size(fmihxpt),iunit)
      write(ioutiunit,*) "fmivxpt"
      call WriteArrayReal(fmivxpt,size(fmivxpt),iunit)
      write(ioutiunit,*) "fmix"
      call WriteArrayReal(fmix,size(fmix),iunit)
      write(ioutiunit,*) "fmixy"
      call WriteArrayReal(fmixy,size(fmixy),iunit)
      write(ioutiunit,*) "fmiy"
      call WriteArrayReal(fmiy,size(fmiy),iunit)
      write(ioutiunit,*) "fnix"
      call WriteArrayReal(fnix,size(fnix),iunit)
      write(ioutiunit,*) "fnixcb"
      call WriteArrayReal(fnixcb,size(fnixcb),iunit)
      write(ioutiunit,*) "fniy"
      call WriteArrayReal(fniy,size(fniy),iunit)
      write(ioutiunit,*) "fniy4ord"
      call WriteArrayReal(fniy4ord,size(fniy4ord),iunit)
      write(ioutiunit,*) "fniycb"
      call WriteArrayReal(fniycb,size(fniycb),iunit)
      write(ioutiunit,*) "fniycbo"
      call WriteArrayReal(fniycbo,size(fniycbo),iunit)
      write(ioutiunit,*) "fqp"
      call WriteArrayReal(fqp,size(fqp),iunit)
      write(ioutiunit,*) "frice"
      call WriteArrayReal(frice,size(frice),iunit)
      write(ioutiunit,*) "frici"
      call WriteArrayReal(frici,size(frici),iunit)
      write(ioutiunit,*) "fricnrl"
      call WriteArrayReal(fricnrl,size(fricnrl),iunit)
      write(ioutiunit,*) "fxe"
      write(ioutiunit,*) fxe
      write(ioutiunit,*) "fxi"
      write(ioutiunit,*) fxi
      write(ioutiunit,*) "ghxpt"
      write(ioutiunit,*) ghxpt
      write(ioutiunit,*) "gpex"
      call WriteArrayReal(gpex,size(gpex),iunit)
      write(ioutiunit,*) "gpey"
      call WriteArrayReal(gpey,size(gpey),iunit)
      write(ioutiunit,*) "gpix"
      call WriteArrayReal(gpix,size(gpix),iunit)
      write(ioutiunit,*) "gpiy"
      call WriteArrayReal(gpiy,size(gpiy),iunit)
      write(ioutiunit,*) "gprx"
      call WriteArrayReal(gprx,size(gprx),iunit)
      write(ioutiunit,*) "gpry"
      call WriteArrayReal(gpry,size(gpry),iunit)
      write(ioutiunit,*) "gtex"
      call WriteArrayReal(gtex,size(gtex),iunit)
      write(ioutiunit,*) "gtey"
      call WriteArrayReal(gtey,size(gtey),iunit)
      write(ioutiunit,*) "gtix"
      call WriteArrayReal(gtix,size(gtix),iunit)
      write(ioutiunit,*) "gtiy"
      call WriteArrayReal(gtiy,size(gtiy),iunit)
      write(ioutiunit,*) "gvxpt"
      write(ioutiunit,*) gvxpt
      write(ioutiunit,*) "hcxe"
      call WriteArrayReal(hcxe,size(hcxe),iunit)
      write(ioutiunit,*) "hcxg"
      call WriteArrayReal(hcxg,size(hcxg),iunit)
      write(ioutiunit,*) "hcxi"
      call WriteArrayReal(hcxi,size(hcxi),iunit)
      write(ioutiunit,*) "hcxij"
      call WriteArrayReal(hcxij,size(hcxij),iunit)
      write(ioutiunit,*) "hcxineo"
      call WriteArrayReal(hcxineo,size(hcxineo),iunit)
      write(ioutiunit,*) "hcxn"
      call WriteArrayReal(hcxn,size(hcxn),iunit)
      write(ioutiunit,*) "hcye"
      call WriteArrayReal(hcye,size(hcye),iunit)
      write(ioutiunit,*) "hcyg"
      call WriteArrayReal(hcyg,size(hcyg),iunit)
      write(ioutiunit,*) "hcyi"
      call WriteArrayReal(hcyi,size(hcyi),iunit)
      write(ioutiunit,*) "hcyij"
      call WriteArrayReal(hcyij,size(hcyij),iunit)
      write(ioutiunit,*) "hcyn"
      call WriteArrayReal(hcyn,size(hcyn),iunit)
      write(ioutiunit,*) "i1"
      write(ioutiunit,*) i1
      write(ioutiunit,*) "i2"
      write(ioutiunit,*) i2
      write(ioutiunit,*) "i2p"
      write(ioutiunit,*) i2p
      write(ioutiunit,*) "i3"
      write(ioutiunit,*) i3
      write(ioutiunit,*) "i4"
      write(ioutiunit,*) i4
      write(ioutiunit,*) "i5"
      write(ioutiunit,*) i5
      write(ioutiunit,*) "i5m"
      write(ioutiunit,*) i5m
      write(ioutiunit,*) "i6"
      write(ioutiunit,*) i6
      write(ioutiunit,*) "i7"
      write(ioutiunit,*) i7
      write(ioutiunit,*) "i8"
      write(ioutiunit,*) i8
      write(ioutiunit,*) "ixf6"
      write(ioutiunit,*) ixf6
      write(ioutiunit,*) "ixs1"
      write(ioutiunit,*) ixs1
      write(ioutiunit,*) "iyf6"
      write(ioutiunit,*) iyf6
      write(ioutiunit,*) "iys1"
      write(ioutiunit,*) iys1
      write(ioutiunit,*) "j1"
      write(ioutiunit,*) j1
      write(ioutiunit,*) "j1p"
      write(ioutiunit,*) j1p
      write(ioutiunit,*) "j2"
      write(ioutiunit,*) j2
      write(ioutiunit,*) "j2p"
      write(ioutiunit,*) j2p
      write(ioutiunit,*) "j3"
      write(ioutiunit,*) j3
      write(ioutiunit,*) "j4"
      write(ioutiunit,*) j4
      write(ioutiunit,*) "j5"
      write(ioutiunit,*) j5
      write(ioutiunit,*) "j5m"
      write(ioutiunit,*) j5m
      write(ioutiunit,*) "j5p"
      write(ioutiunit,*) j5p
      write(ioutiunit,*) "j6"
      write(ioutiunit,*) j6
      write(ioutiunit,*) "j6p"
      write(ioutiunit,*) j6p
      write(ioutiunit,*) "j7"
      write(ioutiunit,*) j7
      write(ioutiunit,*) "j8"
      write(ioutiunit,*) j8
      write(ioutiunit,*) "k2neo"
      call WriteArrayReal(k2neo,size(k2neo),iunit)
      write(ioutiunit,*) "ktneo"
      call WriteArrayReal(ktneo,size(ktneo),iunit)
      write(ioutiunit,*) "kxbohm"
      call WriteArrayReal(kxbohm,size(kxbohm),iunit)
      write(ioutiunit,*) "kxe_use"
      call WriteArrayReal(kxe_use,size(kxe_use),iunit)
      write(ioutiunit,*) "kxi_use"
      call WriteArrayReal(kxi_use,size(kxi_use),iunit)
      write(ioutiunit,*) "kybohm"
      call WriteArrayReal(kybohm,size(kybohm),iunit)
      write(ioutiunit,*) "kye_use"
      call WriteArrayReal(kye_use,size(kye_use),iunit)
      write(ioutiunit,*) "kyi_use"
      call WriteArrayReal(kyi_use,size(kyi_use),iunit)
      write(ioutiunit,*) "lng"
      call WriteArrayReal(lng,size(lng),iunit)
      write(ioutiunit,*) "mfl"
      write(ioutiunit,*) mfl
      write(ioutiunit,*) "msh"
      write(ioutiunit,*) msh
      write(ioutiunit,*) "msor"
      call WriteArrayReal(msor,size(msor),iunit)
      write(ioutiunit,*) "msorold"
      call WriteArrayReal(msorold,size(msorold),iunit)
      write(ioutiunit,*) "msorxr"
      call WriteArrayReal(msorxr,size(msorxr),iunit)
      write(ioutiunit,*) "msorxrold"
      call WriteArrayReal(msorxrold,size(msorxrold),iunit)
      write(ioutiunit,*) "na"
      call WriteArrayReal(na,size(na),iunit)
      write(ioutiunit,*) "ne"
      call WriteArrayReal(ne,size(ne),iunit)
      write(ioutiunit,*) "ney0"
      call WriteArrayReal(ney0,size(ney0),iunit)
      write(ioutiunit,*) "ney1"
      call WriteArrayReal(ney1,size(ney1),iunit)
      write(ioutiunit,*) "nfsp"
      write(ioutiunit,*) nfsp
      write(ioutiunit,*) "ng"
      call WriteArrayReal(ng,size(ng),iunit)
      write(ioutiunit,*) "ngy0"
      call WriteArrayReal(ngy0,size(ngy0),iunit)
      write(ioutiunit,*) "ngy1"
      call WriteArrayReal(ngy1,size(ngy1),iunit)
      write(ioutiunit,*) "ni"
      call WriteArrayReal(ni,size(ni),iunit)
      write(ioutiunit,*) "nit"
      call WriteArrayReal(nit,size(nit),iunit)
      write(ioutiunit,*) "nity0"
      call WriteArrayReal(nity0,size(nity0),iunit)
      write(ioutiunit,*) "nity1"
      call WriteArrayReal(nity1,size(nity1),iunit)
      write(ioutiunit,*) "nixpt"
      call WriteArrayReal(nixpt,size(nixpt),iunit)
      write(ioutiunit,*) "niy0"
      call WriteArrayReal(niy0,size(niy0),iunit)
      write(ioutiunit,*) "niy0s"
      call WriteArrayReal(niy0s,size(niy0s),iunit)
      write(ioutiunit,*) "niy1"
      call WriteArrayReal(niy1,size(niy1),iunit)
      write(ioutiunit,*) "niy1s"
      call WriteArrayReal(niy1s,size(niy1s),iunit)
      write(ioutiunit,*) "nm"
      call WriteArrayReal(nm,size(nm),iunit)
      write(ioutiunit,*) "nratio"
      call WriteArrayReal(nratio,size(nratio),iunit)
      write(ioutiunit,*) "ntau"
      call WriteArrayReal(ntau,size(ntau),iunit)
      write(ioutiunit,*) "nucx"
      call WriteArrayReal(nucx,size(nucx),iunit)
      write(ioutiunit,*) "nucxi"
      call WriteArrayReal(nucxi,size(nucxi),iunit)
      write(ioutiunit,*) "nuelg"
      call WriteArrayReal(nuelg,size(nuelg),iunit)
      write(ioutiunit,*) "nueli"
      call WriteArrayReal(nueli,size(nueli),iunit)
      write(ioutiunit,*) "nuii"
      call WriteArrayReal(nuii,size(nuii),iunit)
      write(ioutiunit,*) "nuiistar"
      call WriteArrayReal(nuiistar,size(nuiistar),iunit)
      write(ioutiunit,*) "nuix"
      call WriteArrayReal(nuix,size(nuix),iunit)
      write(ioutiunit,*) "nuiz"
      call WriteArrayReal(nuiz,size(nuiz),iunit)
      write(ioutiunit,*) "nurc"
      call WriteArrayReal(nurc,size(nurc),iunit)
      write(ioutiunit,*) "nuvl"
      call WriteArrayReal(nuvl,size(nuvl),iunit)
      write(ioutiunit,*) "nz2"
      call WriteArrayReal(nz2,size(nz2),iunit)
      write(ioutiunit,*) "nzloc"
      call WriteArrayReal(nzloc,size(nzloc),iunit)
      write(ioutiunit,*) "openbox"
      write(ioutiunit,*) openbox
      write(ioutiunit,*) "parvis"
      call WriteArrayReal(parvis,size(parvis),iunit)
      write(ioutiunit,*) "pg"
      call WriteArrayReal(pg,size(pg),iunit)
      write(ioutiunit,*) "pgy0"
      call WriteArrayReal(pgy0,size(pgy0),iunit)
      write(ioutiunit,*) "pgy1"
      call WriteArrayReal(pgy1,size(pgy1),iunit)
      write(ioutiunit,*) "phi"
      call WriteArrayReal(phi,size(phi),iunit)
      write(ioutiunit,*) "phiv"
      call WriteArrayReal(phiv,size(phiv),iunit)
      write(ioutiunit,*) "phiy0"
      call WriteArrayReal(phiy0,size(phiy0),iunit)
      write(ioutiunit,*) "phiy0s"
      call WriteArrayReal(phiy0s,size(phiy0s),iunit)
      write(ioutiunit,*) "phiy1"
      call WriteArrayReal(phiy1,size(phiy1),iunit)
      write(ioutiunit,*) "phiy1s"
      call WriteArrayReal(phiy1s,size(phiy1s),iunit)
      write(ioutiunit,*) "pr"
      call WriteArrayReal(pr,size(pr),iunit)
      write(ioutiunit,*) "prad"
      call WriteArrayReal(prad,size(prad),iunit)
      write(ioutiunit,*) "pradc"
      call WriteArrayReal(pradc,size(pradc),iunit)
      write(ioutiunit,*) "pradcff"
      call WriteArrayReal(pradcff,size(pradcff),iunit)
      write(ioutiunit,*) "pradz"
      call WriteArrayReal(pradz,size(pradz),iunit)
      write(ioutiunit,*) "pradzc"
      call WriteArrayReal(pradzc,size(pradzc),iunit)
      write(ioutiunit,*) "pre"
      call WriteArrayReal(pre,size(pre),iunit)
      write(ioutiunit,*) "prev"
      call WriteArrayReal(prev,size(prev),iunit)
      write(ioutiunit,*) "pri"
      call WriteArrayReal(pri,size(pri),iunit)
      write(ioutiunit,*) "priv"
      call WriteArrayReal(priv,size(priv),iunit)
      write(ioutiunit,*) "priy0"
      call WriteArrayReal(priy0,size(priy0),iunit)
      write(ioutiunit,*) "priy1"
      call WriteArrayReal(priy1,size(priy1),iunit)
      write(ioutiunit,*) "prtv"
      call WriteArrayReal(prtv,size(prtv),iunit)
      write(ioutiunit,*) "psor"
      call WriteArrayReal(psor,size(psor),iunit)
      write(ioutiunit,*) "psor_tmpov"
      call WriteArrayReal(psor_tmpov,size(psor_tmpov),iunit)
      write(ioutiunit,*) "psorbgg"
      call WriteArrayReal(psorbgg,size(psorbgg),iunit)
      write(ioutiunit,*) "psorbgz"
      call WriteArrayReal(psorbgz,size(psorbgz),iunit)
      write(ioutiunit,*) "psorc"
      call WriteArrayReal(psorc,size(psorc),iunit)
      write(ioutiunit,*) "psorcxg"
      call WriteArrayReal(psorcxg,size(psorcxg),iunit)
      write(ioutiunit,*) "psorcxgc"
      call WriteArrayReal(psorcxgc,size(psorcxgc),iunit)
      write(ioutiunit,*) "psordis"
      call WriteArrayReal(psordis,size(psordis),iunit)
      write(ioutiunit,*) "psorg"
      call WriteArrayReal(psorg,size(psorg),iunit)
      write(ioutiunit,*) "psorgc"
      call WriteArrayReal(psorgc,size(psorgc),iunit)
      write(ioutiunit,*) "psori"
      call WriteArrayReal(psori,size(psori),iunit)
      write(ioutiunit,*) "psorold"
      call WriteArrayReal(psorold,size(psorold),iunit)
      write(ioutiunit,*) "psorrg"
      call WriteArrayReal(psorrg,size(psorrg),iunit)
      write(ioutiunit,*) "psorrgc"
      call WriteArrayReal(psorrgc,size(psorrgc),iunit)
      write(ioutiunit,*) "psorxr"
      call WriteArrayReal(psorxr,size(psorxr),iunit)
      write(ioutiunit,*) "psorxrc"
      call WriteArrayReal(psorxrc,size(psorxrc),iunit)
      write(ioutiunit,*) "psorxrold"
      call WriteArrayReal(psorxrold,size(psorxrold),iunit)
      write(ioutiunit,*) "pwrebkg"
      call WriteArrayReal(pwrebkg,size(pwrebkg),iunit)
      write(ioutiunit,*) "pwribkg"
      call WriteArrayReal(pwribkg,size(pwribkg),iunit)
      write(ioutiunit,*) "pwrze"
      call WriteArrayReal(pwrze,size(pwrze),iunit)
      write(ioutiunit,*) "pwrzec"
      call WriteArrayReal(pwrzec,size(pwrzec),iunit)
      write(ioutiunit,*) "q2cd"
      call WriteArrayReal(q2cd,size(q2cd),iunit)
      write(ioutiunit,*) "qfl"
      write(ioutiunit,*) qfl
      write(ioutiunit,*) "qipar"
      call WriteArrayReal(qipar,size(qipar),iunit)
      write(ioutiunit,*) "qsh"
      write(ioutiunit,*) qsh
      write(ioutiunit,*) "resco"
      call WriteArrayReal(resco,size(resco),iunit)
      write(ioutiunit,*) "resee"
      call WriteArrayReal(resee,size(resee),iunit)
      write(ioutiunit,*) "resei"
      call WriteArrayReal(resei,size(resei),iunit)
      write(ioutiunit,*) "resmo"
      call WriteArrayReal(resmo,size(resmo),iunit)
      write(ioutiunit,*) "rtau"
      call WriteArrayReal(rtau,size(rtau),iunit)
      write(ioutiunit,*) "rtaue"
      call WriteArrayReal(rtaue,size(rtaue),iunit)
      write(ioutiunit,*) "rtaux"
      call WriteArrayReal(rtaux,size(rtaux),iunit)
      write(ioutiunit,*) "rtauy"
      call WriteArrayReal(rtauy,size(rtauy),iunit)
      write(ioutiunit,*) "seec"
      call WriteArrayReal(seec,size(seec),iunit)
      write(ioutiunit,*) "seev"
      call WriteArrayReal(seev,size(seev),iunit)
      write(ioutiunit,*) "seg_ue"
      call WriteArrayReal(seg_ue,size(seg_ue),iunit)
      write(ioutiunit,*) "seic"
      call WriteArrayReal(seic,size(seic),iunit)
      write(ioutiunit,*) "seiv"
      call WriteArrayReal(seiv,size(seiv),iunit)
      write(ioutiunit,*) "smoc"
      call WriteArrayReal(smoc,size(smoc),iunit)
      write(ioutiunit,*) "smov"
      call WriteArrayReal(smov,size(smov),iunit)
      write(ioutiunit,*) "sng_ue"
      call WriteArrayReal(sng_ue,size(sng_ue),iunit)
      write(ioutiunit,*) "snic"
      call WriteArrayReal(snic,size(snic),iunit)
      write(ioutiunit,*) "sniv"
      call WriteArrayReal(sniv,size(sniv),iunit)
      write(ioutiunit,*) "sxyxpt"
      write(ioutiunit,*) sxyxpt
      write(ioutiunit,*) "te"
      call WriteArrayReal(te,size(te),iunit)
      write(ioutiunit,*) "tev"
      call WriteArrayReal(tev,size(tev),iunit)
      write(ioutiunit,*) "tey0"
      call WriteArrayReal(tey0,size(tey0),iunit)
      write(ioutiunit,*) "tey1"
      call WriteArrayReal(tey1,size(tey1),iunit)
      write(ioutiunit,*) "tg"
      call WriteArrayReal(tg,size(tg),iunit)
      write(ioutiunit,*) "tgy0"
      call WriteArrayReal(tgy0,size(tgy0),iunit)
      write(ioutiunit,*) "tgy1"
      call WriteArrayReal(tgy1,size(tgy1),iunit)
      write(ioutiunit,*) "ti"
      call WriteArrayReal(ti,size(ti),iunit)
      write(ioutiunit,*) "tiv"
      call WriteArrayReal(tiv,size(tiv),iunit)
      write(ioutiunit,*) "tiy0"
      call WriteArrayReal(tiy0,size(tiy0),iunit)
      write(ioutiunit,*) "tiy0s"
      call WriteArrayReal(tiy0s,size(tiy0s),iunit)
      write(ioutiunit,*) "tiy1"
      call WriteArrayReal(tiy1,size(tiy1),iunit)
      write(ioutiunit,*) "tiy1s"
      call WriteArrayReal(tiy1s,size(tiy1s),iunit)
      write(ioutiunit,*) "travis"
      call WriteArrayReal(travis,size(travis),iunit)
      write(ioutiunit,*) "trax_use"
      call WriteArrayReal(trax_use,size(trax_use),iunit)
      write(ioutiunit,*) "tray_use"
      call WriteArrayReal(tray_use,size(tray_use),iunit)
      write(ioutiunit,*) "ttnpg"
      write(ioutiunit,*) ttnpg
      write(ioutiunit,*) "ttotfe"
      write(ioutiunit,*) ttotfe
      write(ioutiunit,*) "ttotjf"
      write(ioutiunit,*) ttotjf
      write(ioutiunit,*) "up"
      call WriteArrayReal(up,size(up),iunit)
      write(ioutiunit,*) "upe"
      call WriteArrayReal(upe,size(upe),iunit)
      write(ioutiunit,*) "upi"
      call WriteArrayReal(upi,size(upi),iunit)
      write(ioutiunit,*) "upxpt"
      call WriteArrayReal(upxpt,size(upxpt),iunit)
      write(ioutiunit,*) "uu"
      call WriteArrayReal(uu,size(uu),iunit)
      write(ioutiunit,*) "uup"
      call WriteArrayReal(uup,size(uup),iunit)
      write(ioutiunit,*) "uz"
      call WriteArrayReal(uz,size(uz),iunit)
      write(ioutiunit,*) "v2"
      call WriteArrayReal(v2,size(v2),iunit)
      write(ioutiunit,*) "v2cb"
      call WriteArrayReal(v2cb,size(v2cb),iunit)
      write(ioutiunit,*) "v2cd"
      call WriteArrayReal(v2cd,size(v2cd),iunit)
      write(ioutiunit,*) "v2ce"
      call WriteArrayReal(v2ce,size(v2ce),iunit)
      write(ioutiunit,*) "v2dd"
      call WriteArrayReal(v2dd,size(v2dd),iunit)
      write(ioutiunit,*) "v2rd"
      call WriteArrayReal(v2rd,size(v2rd),iunit)
      write(ioutiunit,*) "v2xgp"
      call WriteArrayReal(v2xgp,size(v2xgp),iunit)
      write(ioutiunit,*) "ve2cb"
      call WriteArrayReal(ve2cb,size(ve2cb),iunit)
      write(ioutiunit,*) "ve2cd"
      call WriteArrayReal(ve2cd,size(ve2cd),iunit)
      write(ioutiunit,*) "vex"
      call WriteArrayReal(vex,size(vex),iunit)
      write(ioutiunit,*) "vey"
      call WriteArrayReal(vey,size(vey),iunit)
      write(ioutiunit,*) "veycb"
      call WriteArrayReal(veycb,size(veycb),iunit)
      write(ioutiunit,*) "veycp"
      call WriteArrayReal(veycp,size(veycp),iunit)
      write(ioutiunit,*) "visx"
      call WriteArrayReal(visx,size(visx),iunit)
      write(ioutiunit,*) "visxneo"
      call WriteArrayReal(visxneo,size(visxneo),iunit)
      write(ioutiunit,*) "visy"
      call WriteArrayReal(visy,size(visy),iunit)
      write(ioutiunit,*) "visyxpt"
      call WriteArrayReal(visyxpt,size(visyxpt),iunit)
      write(ioutiunit,*) "vsoree"
      call WriteArrayReal(vsoree,size(vsoree),iunit)
      write(ioutiunit,*) "vsoreec"
      call WriteArrayReal(vsoreec,size(vsoreec),iunit)
      write(ioutiunit,*) "vy"
      call WriteArrayReal(vy,size(vy),iunit)
      write(ioutiunit,*) "vy_cft"
      call WriteArrayReal(vy_cft,size(vy_cft),iunit)
      write(ioutiunit,*) "vy_use"
      call WriteArrayReal(vy_use,size(vy_use),iunit)
      write(ioutiunit,*) "vyavis"
      call WriteArrayReal(vyavis,size(vyavis),iunit)
      write(ioutiunit,*) "vycb"
      call WriteArrayReal(vycb,size(vycb),iunit)
      write(ioutiunit,*) "vyce"
      call WriteArrayReal(vyce,size(vyce),iunit)
      write(ioutiunit,*) "vycf"
      call WriteArrayReal(vycf,size(vycf),iunit)
      write(ioutiunit,*) "vycp"
      call WriteArrayReal(vycp,size(vycp),iunit)
      write(ioutiunit,*) "vycr"
      call WriteArrayReal(vycr,size(vycr),iunit)
      write(ioutiunit,*) "vydd"
      call WriteArrayReal(vydd,size(vydd),iunit)
      write(ioutiunit,*) "vygp"
      call WriteArrayReal(vygp,size(vygp),iunit)
      write(ioutiunit,*) "vyhxpt"
      call WriteArrayReal(vyhxpt,size(vyhxpt),iunit)
      write(ioutiunit,*) "vyrd"
      call WriteArrayReal(vyrd,size(vyrd),iunit)
      write(ioutiunit,*) "vytan"
      call WriteArrayReal(vytan,size(vytan),iunit)
      write(ioutiunit,*) "vyte_cft"
      call WriteArrayReal(vyte_cft,size(vyte_cft),iunit)
      write(ioutiunit,*) "vyti_cft"
      call WriteArrayReal(vyti_cft,size(vyti_cft),iunit)
      write(ioutiunit,*) "vyvxpt"
      call WriteArrayReal(vyvxpt,size(vyvxpt),iunit)
      write(ioutiunit,*) "w"
      call WriteArrayReal(w,size(w),iunit)
      write(ioutiunit,*) "w0"
      call WriteArrayReal(w0,size(w0),iunit)
      write(ioutiunit,*) "w1"
      call WriteArrayReal(w1,size(w1),iunit)
      write(ioutiunit,*) "w2"
      call WriteArrayReal(w2,size(w2),iunit)
      write(ioutiunit,*) "w3"
      call WriteArrayReal(w3,size(w3),iunit)
      write(ioutiunit,*) "wjdote"
      call WriteArrayReal(wjdote,size(wjdote),iunit)
      write(ioutiunit,*) "xcnearlb"
      write(ioutiunit,*) xcnearlb
      write(ioutiunit,*) "xcnearrb"
      write(ioutiunit,*) xcnearrb
      write(ioutiunit,*) "zcoef"
      write(ioutiunit,*) zcoef
      write(ioutiunit,*) "zeff"
      call WriteArrayReal(zeff,size(zeff),iunit)
      write(ioutiunit,*) "znot"
      call WriteArrayReal(znot,size(znot),iunit)

      close(iunit)
c$ omp end  parallel
      end subroutine DebugHelper

