diff --git a/bbb/geometry.m b/bbb/geometry.m
index 30257db..0abd7e2 100644
--- a/bbb/geometry.m
+++ b/bbb/geometry.m
@@ -858,9 +858,15 @@ c ... Jump to here for domain decomposition
             call s2fill (nx+2, ny+2, 0., fypxv(0,0,iu), 1, nx+2)
          enddo
       if (isnonog .ge. 1) then
-         call nonorthg
-         do ix = 0, nx+1    # Boundary value set: matters little except vygtan
-            gxfn(ix,0) = gxfn(ix,1)
+         call nonorthg   # Sets dist btwn interp pts as dxnog, dynog
+                         # Also sets nonorth stencils:fx0,fxm,fy0,fym etc
+         do ix = 0, nx+1    # Bdry value set: matters little except vygtan
+ccc            gxfn(ix,0) = gxfn(ix,1)
+            dxnog(ix,0) = dxnog(ix,1)
+	    dxnog(ix,ny+1) = dxnog(ix,ny)
+         enddo
+         do iy = 0, ny+1  # likewise, dxnog(nx+1,) not relevant, but avoid 0
+           dxnog(nx+1,iy) = 0.1*dxnog(nx,iy)
          enddo
       endif
 
@@ -1066,22 +1072,16 @@ c ... radial velocity flow at x-pt is ambiguous; zero out surface area if..
       endif
 
 *---------------------------------------------------------------------
-*     -- Define inverse of distance between density centers
+*     -- Define inverse of distance btwn density cell ctrs
 *---------------------------------------------------------------------
-      do 421 iy = 0, ny
+      do 421 iy = 0,  ny+1
          do 420 ix = 0, nx
             ix1 = ixp1(ix,iy)
             gxf(ix,iy) = 2*gx(ix,iy)*gx(ix1,iy) / (gx(ix,iy)+gx(ix1,iy))
  420     continue
  421  continue
-      do 422 ix = 0, nx
-	 ix1 = ixp1(ix,iy)
-         gxf(ix,ny+1) = 2*gx(ix,ny+1)*gx(ix1,ny+1) /
-     .            	 (gx(ix,ny+1)+gx(ix1,ny+1))
-  422 continue
 
-c...  If nonorthogonal grid is used, gyf & gxfn have already been calculated
-      if (isnonog .eq. 0) then
+c...  Compute gyf for both isnonog=0,1; nonog mesh changes gy & gyf
       do 424 iy = 0, ny
          do 423 ix = 0, nx
             ix1 = ixp1(ix,iy)
@@ -1090,7 +1090,15 @@ c...  If nonorthogonal grid is used, gyf & gxfn have already been calculated
          gyf(nx+1,iy) = 2*gy(nx+1,iy)*gy(nx+1,iy+1)/
      .                	 (gy(nx+1,iy)+gy(nx+1,iy+1))
  424  continue
-      call s2copy (nx+2, ny+2, gxf, 1, nx+2, gxfn, 1, nx+2)
+
+c...  Set dxnog for orthog mesh; if isnonog=1, call to nonorthg above sets
+      if (isnonog==0) then
+        do iy = 0, ny+1
+          do ix = 0, nx+1
+             dxnog(ix,iy) = 1./(gxf(ix,iy) + 1.e-100)
+             dynog(ix,iy) = 1./(gyf(ix,iy) + 1.e-100)
+          enddo
+        enddo
       endif
 
 c...  Calculate a normalization constant for the iy=0 cells
@@ -1381,19 +1389,27 @@ c...  Also reset gyf, so we need the gy calc. after call to nonorthg
               fxp(ixpt2(jx)+ij,iysptrx2(jx),ik)  = 0.
               fxmy(ixpt2(jx)+ij,iysptrx2(jx),ik) = 0.
               fxpy(ixpt2(jx)+ij,iysptrx2(jx),ik) = 0.
-            gyf(ixpt1(jx)+ij,iysptrx1(jx)) = 2*gy(ixpt1(jx)+ij,iysptrx1(jx)) *
+              gyf(ixpt1(jx)+ij,iysptrx1(jx)) = 
+     .                                2*gy(ixpt1(jx)+ij,iysptrx1(jx)) *
      .                              gy(ixpt1(jx)+ij,iysptrx1(jx)+1) / (
-     .               gy(ixpt1(jx)+ij,iysptrx1(jx)) + gy(ixpt1(jx)+ij,iysptrx1(jx)+1) )
-            gyf(ixpt2(jx)+ij,iysptrx2(jx)) = 2*gy(ixpt2(jx)+ij,iysptrx2(jx)) *
+     .                                 gy(ixpt1(jx)+ij,iysptrx1(jx)) + 
+     .                                 gy(ixpt1(jx)+ij,iysptrx1(jx)+1) ) 
+              gyf(ixpt2(jx)+ij,iysptrx2(jx)) = 
+     .                                2*gy(ixpt2(jx)+ij,iysptrx2(jx)) *
      .                              gy(ixpt2(jx)+ij,iysptrx2(jx)+1) / (
-     .               gy(ixpt2(jx)+ij,iysptrx2(jx)) + gy(ixpt2(jx)+ij,iysptrx2(jx)+1) )
+     .                                 gy(ixpt2(jx)+ij,iysptrx2(jx)) + 
+     .                                 gy(ixpt2(jx)+ij,iysptrx2(jx)+1) )
+              dynog(ixpt1(jx)+ij,iysptrx1(jx)) = 
+     .                                 1./gyf(ixpt1(jx)+ij,iysptrx1(jx))
+              dynog(ixpt2(jx)+ij,iysptrx2(jx)) = 
+     .                                 1./gyf(ixpt2(jx)+ij,iysptrx2(jx))
             enddo # end loop on jx 
           enddo # end loop on ij
         enddo # end loop on ik
 
 c...  Reset fym, fy0, fyp around the x-point - only orthogonal coupling
         do ik = 0, 1
-          do ij = -1, 1
+          do ij = 0, 1  #was -1,1; changed 12/13/19
             do jx = 1, nxpt
               fym(ixpt1(jx),iysptrx1(jx)+ij,ik)  = 0.
               fy0(ixpt1(jx),iysptrx1(jx)+ij,ik)  = 1.
@@ -1405,8 +1421,10 @@ c...  Reset fym, fy0, fyp around the x-point - only orthogonal coupling
               fyp(ixpt2(jx),iysptrx2(jx)+ij,ik)  = 0.
               fypx(ixpt2(jx),iysptrx2(jx)+ij,ik) = 0.
               fymx(ixpt2(jx),iysptrx2(jx)+ij,ik) = 0.
-              gxfn(ixpt1(jx),iysptrx2(jx)+ij) = gxf(ixpt1(jx),iysptrx1(jx)+ij)
-              gxfn(ixpt2(jx),iysptrx2(jx)+ij) = gxf(ixpt2(jx),iysptrx2(jx)+ij)
+              dxnog(ixpt1(jx),iysptrx2(jx)+ij) = 
+     .                               1./gxf(ixpt1(jx),iysptrx1(jx)+ij)
+              dxnog(ixpt2(jx),iysptrx2(jx)+ij) = 
+     .                               1./gxf(ixpt2(jx),iysptrx2(jx)+ij)
             enddo # end loop on jx
           enddo # end loop on ij
         enddo # end loop on ik
@@ -1460,8 +1478,8 @@ c...  boundary conditions at midplane for geometry='dnbot'
                fyp(ix,iy,ik)  = 0.
                fymx(ix,iy,ik) = 0.
                fypx(ix,iy,ik) = 0.
-               gxfn(ix,iy) = 2*gx(ix,iy) * gx(ix+1,iy) /
-     .                          ( gx(ix,iy) + gx(ix+1,iy) )
+               dxnog(ix,iy) = ( gx(ix,iy) + gx(ix+1,iy) )/
+     .                        (2*gx(ix,iy) * gx(ix+1,iy))
             enddo
           enddo
         enddo
@@ -1482,7 +1500,7 @@ c...  Reset fym, fy0, fyp at ixpt1,2+0,1 if half-space problem with no flux
                  fyp(ix,iy,ik)  = 0.
                  fypx(ix,iy,ik) = 0.
                  fymx(ix,iy,ik) = 0.
-                 gxfn(ix,iy) = gxf(ix,iy)
+                 dxnog(ix,iy) = 1./gxf(ix,iy)
               enddo
               do iy = 0, ny+1
                  fym(ix2,iy,ik)  = 0.
@@ -1490,7 +1508,7 @@ c...  Reset fym, fy0, fyp at ixpt1,2+0,1 if half-space problem with no flux
                  fyp(ix2,iy,ik)  = 0.
                  fypx(ix2,iy,ik) = 0.
                  fymx(ix2,iy,ik) = 0.
-                 gxfn(ix2,iy) = gxf(ix,iy)
+                 dxnog(ix2,iy) = 1./gxf(ix,iy)
               enddo
            enddo
         endif
@@ -1943,6 +1961,7 @@ c...  be in error.  Thus, linearly extrapolate anfgx at ix=0 and nx with
 c...  adjacent values assuming a uniform mesh (gx not defined yet).
 c...  Also redo vtag.  A similar situation exists near limiter guard
 c...  cells at ix_lim and ix_lim+1. 
+      if(redopltvtag == 1) then
        do iy = 0, ny+1
          angfx(0,iy) = 2*angfx(1,iy) - angfx(2,iy)
          vtag(0,iy) = 2*vtag(1,iy) - vtag(2,iy)
@@ -1971,6 +1990,7 @@ c...  cells at ix_lim and ix_lim+1.
          angfx(nx+1,iy) = angfx(nx,iy)    # not really used
          vtag(nx+1,iy) = vtag(nx,iy)      # not really used
        enddo
+      endif
 
 c...  Set angfx and vtag in the y-guard cells to adjacent values
       do ix = 0, nx+1
@@ -2114,39 +2134,44 @@ ccc      endif
                goto 13
             endif
 c...  Recalculate the distance between y-points normal to y-face
-            dyf = sqrt( (rints(1)-rints(0))**2 +
+c...  For isnonog=1, 1/gyf .ne. dynog
+            dynog(ix,iy) = sqrt( (rints(1)-rints(0))**2 +
      .                             (zints(1)-zints(0))**2 )
-            gyf(ix,iy) = 1/dyf
  20      continue
  21   continue
 
 c...  Approx. the gyf in guard cells around boundary; these should not
 c...  matter except possibly gyf(0,0) for half-space problem & iflcore=1
       do iy = 0, ny
-         gyf(0,iy) = gyf(1,iy)
-         gyf(nx+1,iy) = gyf(nx,iy)
+         dynog(0,iy) = dynog(1,iy)
+         dynog(nx+1,iy) = dynog(nx,iy)
       enddo
 
 c...  Approx. gyf in midplane guard cells for geometry=dnbot, only for 
 c...  corner boundary condition
       if ((isudsym==1.or.(geometry.eq.'dnXtarget')) .and. nxc.gt.0) then
          do iy = 0, ny
-            gyf(nxc,iy) = gyf(nxc-1,iy)
-            gyf(nxc+1,iy) = gyf(nxc+2,iy)
+            dynog(nxc,iy) = dynog(nxc-1,iy)
+            dynog(nxc+1,iy) = dynog(nxc+2,iy)
          enddo
       endif
+c...  Also set dynog(,ny+1) to nonzero; not use - avoid possible 1/dynog
+      do ix = 0, nx+1
+        dynog(ix,ny+1) = 0.1*dynog(ix,ny)
+      enddo
+
 c...  Similarly approximate gyf for limiter guard cells
       if (islimon .ne. 0) then
          do iy = 0, ny
-            gyf(ix_lim,iy) = gyf(ix_lim-1,iy)
-            gyf(ix_lim+1,iy) = gyf(ix_lim+2,iy)
+            dynog(ix_lim,iy) = dynog(ix_lim-1,iy)
+            dynog(ix_lim+1,iy) = dynog(ix_lim+2,iy)
          enddo
       endif
 c...  Similarly approximate gyf for upper target plate guard cells
       if (nxpt==2) then
          do iy = 0, ny
-            gyf(ixrb(1)+1,iy) = gyf(ixrb(1),iy)
-            gyf(ixlb(2),iy) = gyf(ixlb(2)+1,iy)
+            dynog(ixrb(1)+1,iy) = dynog(ixrb(1),iy)
+            dynog(ixlb(2),iy) = dynog(ixlb(2)+1,iy)
          enddo
       endif
 
@@ -2171,19 +2196,20 @@ c...  of the x-face.
       do 41 ix = 0, nx 
 ccc	 if (isudsym==1 .and. ix==nxc) goto 41
 ccc         # skip non-physical interface between inboard and outboard midplane
-
          do 40 iy = 1, ny
 c...  Fix possible divide-by-zero
            if ( isoldgrid .eq. 1) then #only use to retrieve pre-1/96 solution
             if ( rm(ix+nj,iy,4) .eq. rm(ix+nj,iy,2) .or.
      .              abs(zm(ix+nj,iy,4)-zm(ix+nj,iy,2)) .lt. 1.e-9 ) then
-               gxfn(ix,iy) = 1. /
+               dxnog(ix,iy) =
      .                sqrt( (rm(ixp1(ix,iy)+nj,iy,0)-rm(ix+nj,iy,0))**2 +
      .                      (zm(ixp1(ix,iy)+nj,iy,0)-zm(ix+nj,iy,0))**2 )
+               if (isudsym==1 .and. ix==nxc) dxnog(ix,iy)= 1.e-20  #just small
                goto 40
             endif
            endif
-c...  fix possible divide-by-zero
+
+c...  fix possible divide-by-zero; normally compute (R,Z) slope of x-face
            if ( rm(ix+nj,iy,4) .eq. rm(ix+nj,iy,2) ) then
               slp1 = bigslp
            elseif ( zm(ix+nj,iy,4) .eq. zm(ix+nj,iy,2) ) then
@@ -2192,9 +2218,37 @@ c...  fix possible divide-by-zero
               slp1 =(zm(ix+nj,iy,4)-zm(ix+nj,iy,2))/
      .                                  (rm(ix+nj,iy,4)-rm(ix+nj,iy,2))
            endif
+
+cc_new            if ( rm(ix+nj,iy,4) .eq. rm(ix+nj,iy,2) ) then
+cc_new                slp0 = bigslp
+cc_new             elseif ( zm(ix+nj,iy,4) .eq. zm(ix+nj,iy,2) ) then
+cc_new                slp0 = 1/bigslp
+cc_new             else
+cc_new                slp0 =(zm(ix+nj,iy,4)-zm(ix+nj,iy,2))/
+cc_new      .                                   (rm(ix+nj,iy,4)-rm(ix+nj,iy,2))
+cc_new             endif
+
+c...  Set (R,Z) coordinate at midpoint of x-face
             zmid = 0.5*(zm(ix+nj,iy,4)+zm(ix+nj,iy,2))
             rmid = 0.5*(rm(ix+nj,iy,4)+rm(ix+nj,iy,2))
             ishx = 0
+
+c...  First find intersection to normal to x-face to its left & set tilt param
+cc_new            if(angfx(ix,iy) > 0) then
+cc_new              ishy = 1  # search upward from (ix,iy) cell
+cc_new            else
+cc_new              ishy = 0  # search downward
+cc_new            endif
+cc_new
+cc_new            ishx = 0
+cc_new            if(angfx(ix,iy) > 0) then
+cc_new              ishy = 1  # search upward from (ix,iy) cell
+cc_new            else
+cc_new              ishy = 0  # search downward
+cc_new            endif
+cc_new            call lindis2(ix,iy,rmid,zmid,slpl,ishx,ishy)
+
+
             iyu1 = iy
  33         ixu1 = (1-ishx)*ix + ishx*ixp1(ix,iyu1)
             if ( angfx(ix,iy)*(1-2*ishx) .ge. 0) then #setup most likely diag
@@ -2251,12 +2305,15 @@ c ...       Search for intersection btwn (ixu1,iyu1) & (ixu2,iyu2)
                goto 33
             endif
 c...  Calculate the distance between interpolated pts normal to x-face
-c...  Include the bend in the flux surface through angles angfs1,2
+c...  Include bend in flux surface through angles angfs1,2; here cmt out.
+c...  For isnonog=1, 1/gxf .ne. dxnog as interp pts not along cell ctrs
+
 
-            dxf = sqrt( (rints(1)-rints(0))**2 +
+            dxnog(ix,iy) = sqrt( (rints(1)-rints(0))**2 + 
      .                           (zints(1)-zints(0))**2 )
 ccc     .                  / abs( cos(0.5*(angfs1-angfs2)) )
-            gxfn(ix,iy) = 1/dxf
+ccc            gxfn(ix,iy) = 1/dxf
+            
  40      continue
  41   continue
 
@@ -2404,6 +2461,206 @@ c ---------------------------------------------------------------------
       return
       end
 c ***** end of subroutine lindis *****************
+c *****
+      subroutine lindis2 (p1,q1,rmf,zmf,slpmf,isx,isy,idone)
+C  THIS IS WORK-IN-PROGRESS FOR NEW INTERPOLATOR: NOT CALLED
+c
+******************************************************************************
+*     LINDIS2 finds the intersection of two lines, one defined by the
+*     perpendicular to a face obeying the equation z=zmf-(r-zmf)/slpmf,
+*     where (rmf,zmf) gives the center of the face and slpmf is the face slope
+*     face; thus, -1/slpmf is the slope of the perpendicular. The second line
+*     connects two other points on the mesh as is defined below - search along
+*     line segments between cell centers and midpoints of faces to follow
+*     along the mesh lines even if the cells form a curved surface. The index
+*     isx (ishx) specifies search to left of face (isx=0) or to the right 
+*     (isx=1).  Also, isy is determined by angfx > 0 or < 0, which determines
+*     the direction of the search (upward if isy=1, downward if isy=0).
+*     See related figures of the stencil patterns for a visual picture.
+*        d1 = distance between (rx,zx) and (r1,z1), 
+*        d2 = distance between (rx,zx) and (r2,z2) 
+*        d3 = distance between (r1,z1) and (r2,z2), 
+****************************************************************************
+      implicit none
+      Use(Dim)            # nx,ny
+      Use(RZ_grid_info)   # rm,zm
+      Use(Share)          # nxomit
+      Use(Noggeo)         # fy0,fym,fyp etc
+      Use(Comgeo)         # dxnog
+      Use(Selec)          # ixp1 
+
+*  -- Input scalars --
+      integer p1,q1,isx,isy          # indices of pts (p1,q1) & (i2,j2) & face switch
+      real rmf,zmf,slpmf       # slope of face, and midpoint (rmf,zmf)
+
+*  -- Output scalars --          
+      real rx,zx,d12,d1x,d2x #intersection (rx,zx) and distances (see above)
+      integer idone
+
+*  -- Local scalars --
+      real r1,z1,r2,z2	     #coordinates of two pts defining 2nd line
+                             #connecting alternate cell ctrs & cell faces
+      real slpn,slp2         #slope of normal to x-face (=-11/slpmf)
+      real dcf
+      integer nj,isg,ixc,iyc
+ 
+      idone = 0
+      nj = max(0, nxomit)
+
+c... ************************************************************************
+c...  Search up (isy=0) or down (isy=1) in iy for fix ix, then ix at fixed iy
+c... ************************************************************************
+      do isg = 1, 3   #consider 3 center-to-face vert sgmts for intersection
+	iyc = q1 + sign(isg/2,-isy)
+        if(isy==0) then
+          ixc = p1 + nj
+        else
+          ixc = ixp1(p1+nj,iyc)
+        endif
+        if (isg/2 == (isg+1)/2) then   #isg even, r1,z1 on y-face
+          r1 = 0.5*(rm(ixc,iyc,2+2*isy) + rm(ixc,iyc,1+2*isy)) # y-face
+          z1 = 0.5*(zm(ixc,iyc,2+2*isy) + zm(ixc,iyc,1+2*isy)) # y-face
+        else    #isg odd, so r1,z1 is cell ctr
+          r1 = rm(ixc,iyc,0)	# cell ctr
+          z1 = zm(ixc,iyc,0)	# cell ctr
+        endif
+c...  First line segment btw (r1,z1) y-face below (iys=0) or above (iys=1)
+c...  Find slope of second line, and solve for intersection (rx,zx)
+        if(isg == 1) then  #r2,z2 only set for isg=1; then use last r1,z1
+          r2 =0.5*(rm(ixc,iyc,2+2*isy) + rm(ixc,iyc,1+2*isy)) # y-face
+          z2 =0.5*(zm(ixc,iyc,2+2*isy) + zm(ixc,iyc,1+2*isy)) # y-face
+        endif
+        slp2 = (z1-z2) / (r1-r2+1.e-20)	 #slope of r1,z1-r2,z2 line segment
+        slpn = -1./(slpmf+1.e-20)        #slope of normal to x-face
+c...  Solution of 2 linear eqns (lines) for intersection rx,zx
+        zx = (slpn*zmf - slp2*z2 + r2 - rmf)/(slpn-slp2+1.e-20)
+        rx = slpn*(zx-zmf) + rmf
+
+c...  Compute distances btwn pts 1,2, and btwn intersect rx,zx & pts 1,2
+        d12 = sqrt((r1-r2)**2 + (z1-z2)**2)
+        d1x = sqrt((rx-r1)**2 + (zx-z1)**2)
+        d2x = sqrt((rx-r2)**2 + (zx-r2)**2)
+
+c...  Set dist btwn cell ctr & adj face just beyond line segmt 1,2
+        if(isg==1) then      #here r2,z2 is lower (upper) iy-face
+          dcf = sqrt((r2-rm(ixc,iyc-1+2*isy,0))**2 +
+     .               (z2-zm(ixc,iyc-1+2*isy,0))**2)
+        elseif(isg==2) then  #here r1,z1 is upper (lower) iy-face
+          dcf = sqrt((r1-rm(ixc,iyc-2,0))**2 +
+     .               (z1-zm(ixc,iyc-2,0))**2)
+        elseif(isg==3) then  #here r2,z2 is upper (lower) iy-face
+          dcf = sqrt((r2-rm(ixc,iyc-1+isy,0))**2 +
+     .               (z2-zm(ixc,iyc-1+isy,0))**2)
+        endif
+c...  Check if d1x and d2x < d12; if so, record stencil  values & exit
+        if (d12 > d1x .and. d12 > d2x) then  #note then d12=d1x+d2x
+          dxnog(p1+nj,q1) = dxnog(p1+nj,q1)+sqrt((rmf-rx)**2+(zmf-zx)**2)
+          if(isy==0) then
+            if(isg==1) then
+              fym(p1+nj,q1,0) = d1x/(dcf+d12)
+              fy0(p1+nj,q1,0) = (dcf+d2x)/(dcf+d12)
+            elseif(isg==2) then
+              fy0(p1+nj,q1,0) = (dcf+d1x)/(dcf+d12)
+              fyp(p1+nj,q1,0) = d2x/(dcf+d12)
+            elseif(isg==3) then
+              fy0(p1+nj,q1,0) = d1x/(dcf+d12)
+              fyp(p1+nj,q1,0) = (dcf+d2x)/(dcf+d12)
+            endif
+          elseif(isy==1) then
+            if(isg==1) then
+              fyp(p1+nj,q1,1) = d1x/(dcf+d12)
+              fy0(p1+nj,q1,1) = (dcf+d2x)/(dcf+d12)
+            elseif(isg==2) then
+              fy0(p1+nj,q1,1) = (dcf+d1x)/(dcf+d12)
+              fym(p1+nj,q1,1) = d2x/(dcf+d12)
+            elseif(isg==3) then
+              fy0(p1+nj,q1,1) = d1x/(dcf+d12)
+              fym(p1+nj,q1,1) = (dcf+d2x)/(dcf+d12)
+            endif
+          endif
+          idone = 1
+          break
+        endif     #testing if valid intersection is found
+
+        r2 = r1
+        z2 = z1
+      enddo
+
+c... ************************************************************************
+c...  Similar coding to search right/left if no intersect in iy (idone=0)
+c... ************************************************************************
+      if(idone == 1) return
+      do isg = 1,2   #consider 2 center-to-face horiz sgmts for intersection
+        ixc = p1 + nj #sign(1,-isy)*isg/2
+	iyc = q1 + 1 - 2*isy
+        if (isg == 2) then   #isg even, r1,z1 at cell ctr
+          if(isy==0) ixc = ixp1(ixc,iyc)
+          r1 = rm(ixc,iyc,0)	# cell ctr
+          z1 = zm(ixc,iyc,0)	# cell ctr
+        else    #isg odd (=1), so r1,z1 on cell face
+          if(isy==1) ixc = ixp1(ixc,iyc)
+          r1 =0.5*(rm(ixc,iyc,2-isy) + rm(ixc,iyc,4-isy)) # x-face
+          z1 =0.5*(zm(ixc,iyc,2-isy) + zm(ixc,iyc,4-isy)) # x-face
+        endif
+c...  First line segment btw (r1,z1) x-face to right (iys=0) or left (iys=1)
+c...  Find slope of second line, and solve for intersection (rx,zx)
+        if(isg == 1) then  #r2,z2 only set for isg=1; then use last r1,z1
+          r2 = rm(ixc,iyc,0)            # cell ctr
+          z2 = zm(ixc,iyc,0)            # cell ctr
+        endif
+        slp2 = (z1-z2) / (r1-r2+1.e-20)	 #slope of line segment
+        slpn = -1./(slpmf+1.e-20)        #slope of normal to x-face
+        zx = (slpn*zmf - slp2*z2 + r2 - rmf)/(slpn-slp2+1.e-20)
+        rx = slpn*(zx-zmf) + rmf
+
+c...  Compute distances btwn pts 1,2, and btwn intersect rx,zx & pts 1,2
+        d12 = sqrt((r1-r2)**2 + (z1-z2)**2)
+        d1x = sqrt((rx-r1)**2 + (zx-z1)**2)
+        d2x = sqrt((rx-r2)**2 + (zx-r2)**2)
+
+c...  If isg=1, first set dist btwn right-most(left-most)cell ctr & adj face
+c...  Here for isg=1, r1,z1 is cell x-face, so rm,zm is shifted cell ctr
+        if(isg==1) then
+          if(isy==0) ixc=ixp1(p1+nj,iyc)
+          if(isy==1) ixc=p1+nj
+          dcf = sqrt((r1-rm(ixc,iyc,0))**2 + (z1-zm(ixc,iyc,0))**2)
+        elseif(isg==2) then
+          if(isy==0) ixc=p1+nj
+          if(isy==1) ixc=ixp1(p1+nj,iyc)
+          dcf = sqrt((r2-rm(ixc,iyc,0))**2 + (z2-zm(ixc,iyc,0))**2)
+        endif
+
+c...  Check if d1x and d2x < d12; if so, record stencil values & exit
+        if (d12 > d1x .and. d12 > d2x) then  #note then d12=d1x+d2x
+          dxnog(p1+nj,q1) = dxnog(p1+nj,q1)+sqrt((rmf-rx)**2+(zmf-zx)**2)
+          if(isy==0) then
+            if(isg==1) then
+              fyp(p1+nj,q1,0) = d2x/(dcf+d12)
+              fypx(p1+nj,q1,0) = (dcf+d1x)/(dcf+d12)
+            elseif(isg==2) then
+              fyp(p1+nj,q1,0) = d1x/(dcf+d12)
+              fypx(p1+nj,q1,0) = (dcf+d2x)/(dcf+d12)
+            endif
+          elseif(isy==1) then
+            if(isg==1) then
+              fym(p1+nj,q1,1) = d2x/(dcf+d12)
+              fymx(p1+nj,q1,1) = (dcf+d1x)/(dcf+d12)
+            elseif(isg==2) then
+              fym(p1+nj,q1,1) = d1x/(dcf+d12)
+              fymx(p1+nj,q1,1) = (dcf+d2x)/(dcf+d12)           
+            endif
+          endif
+          idone = 1
+          break
+        endif     #testing if valid intersection is found
+
+        r2 = r1
+        z2 = z1
+      enddo
+
+      return
+      end
+c ***** end of subroutine lindis2 *****************
 c ---------------------------------------------------------------------
 
       subroutine grdnrm (nx,ny,ixlb,ixpt1,ixpt2,ixrb,iysptrx,isgindx,
diff --git a/bbb/oderhs.m b/bbb/oderhs.m
index cd46242..801c21a 100755
--- a/bbb/oderhs.m
+++ b/bbb/oderhs.m
@@ -1283,10 +1283,10 @@ cc              endif
 
               vydd(ix,iy,ifld) = vydd(ix,iy,ifld) 
      .           -1. * difnimix * (
-     .            2*(1-isvylog)*(niy1(ix,iy,ifld) - niy0(ix,iy,ifld)) *
-     .              gyf(ix,iy) / (niy1(ix,iy,ifld) + niy0(ix,iy,ifld))+
+     .            2*(1-isvylog)*( (niy1(ix,iy,ifld) - niy0(ix,iy,ifld)) /
+     .              dynog(ix,iy) ) / (niy1(ix,iy,ifld)+niy0(ix,iy,ifld))+
      .              isvylog*(log(niy1(ix,iy,ifld)) - 
-     .                             log(niy0(ix,iy,ifld))) *gyf(ix,iy) )
+     .                            log(niy0(ix,iy,ifld))) /dynog(ix,iy) )
 
 c ... Compute total radial velocity.
               vy(ix,iy,ifld) = cfydd *bfacyrozh(ix,iy) *
@@ -1420,7 +1420,7 @@ c     .                    fy0 (ix,iy,0)/ni(ix ,iy ,ifld) +
 c     .                    fyp (ix,iy,0)/ni(ix ,iy2,ifld) + 
 c     .                    fymx(ix,iy,0)/ni(ix4,iy1,ifld) +
 c     .                    fypx(ix,iy,0)/ni(ix6,iy2,ifld) ) )
-c     .                                                 * gxfn(ix,iy)
+c     .                                                 / dxnog(ix,iy)
 cc            grdnv = ( exp( fym (ix,iy,1)*log(ni(ix2,iy1,ifld)) + 
 cc     .                     fy0 (ix,iy,1)*log(ni(ix2,iy ,ifld)) +
 cc     .                     fyp (ix,iy,1)*log(ni(ix2,iy2,ifld)) +
@@ -1430,8 +1430,8 @@ cc     .               -exp( fym (ix,iy,0)*log(ni(ix ,iy1,ifld)) +
 cc     .                     fy0 (ix,iy,0)*log(ni(ix ,iy ,ifld)) +
 cc     .                     fyp (ix,iy,0)*log(ni(ix ,iy2,ifld)) +
 cc     .                     fymx(ix,iy,0)*log(ni(ix4,iy1,ifld)) +
-cc     .                     fypx(ix,iy,0)*log(ni(ix6,iy2,ifld)) ) ) *
-cc     .                                                      gxfn(ix,iy)
+cc     .                     fypx(ix,iy,0)*log(ni(ix6,iy2,ifld)) ) ) /
+cc     .                                                    dxnog(ix,iy)
             grdnv = (    ( fym (ix,iy,1)*log(ni(ix2,iy1,ifld)) + 
      .                     fy0 (ix,iy,1)*log(ni(ix2,iy ,ifld)) +
      .                     fyp (ix,iy,1)*log(ni(ix2,iy2,ifld)) +
@@ -1441,8 +1441,8 @@ cc     .                                                      gxfn(ix,iy)
      .                     fy0 (ix,iy,0)*log(ni(ix ,iy ,ifld)) +
      .                     fyp (ix,iy,0)*log(ni(ix ,iy2,ifld)) +
      .                     fymx(ix,iy,0)*log(ni(ix4,iy1,ifld)) +
-     .                     fypx(ix,iy,0)*log(ni(ix6,iy2,ifld)) ) ) *
-     .                                                      gxfn(ix,iy)
+     .                     fypx(ix,iy,0)*log(ni(ix6,iy2,ifld)) ) ) /
+     .                                                      dxnog(ix,iy)
             vytan(ix,iy,ifld)=(fcdif*difni(ifld) + dif_use(ix,iy,ifld)) *
      .                                      (grdnv/cos(angfx(ix,iy)) - 
      .                       (log(ni(ix2,iy,ifld)) - log(ni(ix,iy,ifld)))
@@ -2958,7 +2958,7 @@ c          Now for the radial flux limit - good for nonorthog grid too
                lmfpn = 1./(sigcx * (niavey + rnn2cx*noavey))
                cshy = lmfpn*sqrt(tgavey/mi(iigsp))*noavey * 
      .                         lgtmax(iigsp)/(lmfpn + lgtmax(iigsp))
-               qshy = cshy * (tgy0(ix,iy1,1)-tgy1(ix,iy1,1)) * gyf(ix,iy)
+               qshy = cshy * (tgy0(ix,iy1,1)-tgy1(ix,iy1,1))/dynog(ix,iy)
                hcyn(ix,iy) = cshy / 
      .                      (1 + (abs(qshy/qfly))**flgamtg)**(1./flgamtg)
                hcyi(ix,iy) = hcyi(ix,iy) + cfneut*cfneutsor_ei*hcyn(ix,iy)
@@ -3045,7 +3045,8 @@ c..   Now radial direction
      .                 naavey*kelhmhg
             qfly = flalftmy*sqrt(tgavey/mg(igsp))*noavey*tgavey
             cshy = cftgcond*noavey*tgavey/(mg(igsp)*nuelmoly)  #assume Kel_s not fcn Tg
-            qshy = cshy*(tgy0(ix,iy1,igsp)-tgy1(ix,iy1,igsp))*gyf(ix,iy)
+            qshy = cshy*(tgy0(ix,iy1,igsp)-tgy1(ix,iy1,igsp))/
+     .                                                  dynog(ix,iy)
             hcyg(ix,iy,igsp) = cshy / 
      .                     (1 + (abs(qshy/qfly))**flgamtg)**(1./flgamtg)
             hcyg(ix,iy,igsp)=(1-cfhcygc(igsp))*hcyg(ix,iy,igsp)+
@@ -3456,9 +3457,9 @@ c     The density-stencil dxnog has to be averaged as well.
      .                  fy0v (ix,iy,0)*up(ix1,iy  ,ifld)-
      .                  fypv (ix,iy,0)*up(ix5,iy+1,ifld)-
      .                  fymxv(ix,iy,0)*up(ix ,iy1 ,ifld)-
-     .                  fypxv(ix,iy,0)*up(ix ,iy+1,ifld) ) *
-     .                     (2*gxfn(ix,iy)*gxfn(ix1,iy) /
-     .                      (gxfn(ix,iy)+gxfn(ix1,iy)))
+     .                  fypxv(ix,iy,0)*up(ix ,iy+1,ifld) ) /
+     .                     ( 2*dxnog(ix,iy)*dxnog(ix1,iy) /
+     .                       (dxnog(ix,iy)+dxnog(ix1,iy)) )
                if (isgxvon .eq. 0) then
                   fmixy(ix,iy,ifld) = cfvisxy(ifld)*visy(ix,iy,ifld) *
      .              ( grdnv/cos(0.5*(angfx(ix1,iy)+angfx(ix,iy))) - 
@@ -3468,8 +3469,8 @@ c     The density-stencil dxnog has to be averaged as well.
                   fmixy(ix,iy,ifld) = cfvisxy(ifld)*visy(ix,iy,ifld) *
      .              ( grdnv/cos(0.5*(angfx(ix1,iy)+angfx(ix,iy))) - 
      .               (up(ix,iy,ifld) - up(ix1,iy,ifld))*
-     .                     (2*gxfn(ix,iy)*gxfn(ix1,iy) /
-     .                      (gxfn(ix,iy)+gxfn(ix1,iy))) ) *
+     .                     ( 2*gxf(ix,iy)*gxf(ix1,iy) /
+     .                        (gxf(ix,iy)+gxf(ix1,iy)) ) ) *
      .                     0.5*(sx(ix1,iy)+sx(ix,iy))
                endif
 c...  Now flux limit with flalfvgxy if ifld=2
@@ -3854,8 +3855,8 @@ c.... Now do the ions (hcxi is flux-limited previously when it is built)
 
       do 123 iy = j1, j5
          do 122 ix = i4, i8
-            conye(ix,iy) = sy(ix,iy) * hcye(ix,iy) * gyf(ix,iy)
-            conyi(ix,iy) = sy(ix,iy) * hcyi(ix,iy) * gyf(ix,iy)
+            conye(ix,iy) = sy(ix,iy) * hcye(ix,iy) / dynog(ix,iy)
+            conyi(ix,iy) = sy(ix,iy) * hcyi(ix,iy) / dynog(ix,iy)
   122    continue
   123 continue
 
@@ -4192,8 +4193,8 @@ c...  First do the Te equation
      .                        fy0 (ix,iy,0)*log(te(ix ,iy  )) +
      .                        fyp (ix,iy,0)*log(te(ix ,iy+1)) +
      .                        fymx(ix,iy,0)*log(te(ix4,iy1 )) +  
-     .                        fypx(ix,iy,0)*log(te(ix6,iy+1)) ) ) *
-     .                                                   gxfn(ix,iy)
+     .                        fypx(ix,iy,0)*log(te(ix6,iy+1)) ) ) / 
+     .                                                   dxnog(ix,iy)  
                feexy(ix,iy) = exp( 0.5*
      .                         (log(te(ix2,iy)) + log(te(ix,iy))) )* 
      .                               (fcdif*kye+kye_use(ix,iy))*0.5*
@@ -4220,8 +4221,8 @@ c --- a nonorthogonal mesh because of niy1,0 - see def. of hcyn
      .                         fy0 (ix,iy,0)*log(ti(ix ,iy  )) +
      .                         fyp (ix,iy,0)*log(ti(ix ,iy+1)) +
      .                         fymx(ix,iy,0)*log(ti(ix4,iy1 )) +  
-     .                         fypx(ix,iy,0)*log(ti(ix6,iy+1)) ) ) *
-     .                                                   gxfn(ix,iy)
+     .                         fypx(ix,iy,0)*log(ti(ix6,iy+1)) ) ) / 
+     .                                                   dxnog(ix,iy)  
                feixy(ix,iy) = exp( 0.5*
      .                       (log(ti(ix2,iy)) + log(ti(ix,iy))) )*
      .                           ( (fcdif*kyi+kyi_use(ix,iy))*0.5*
@@ -5470,8 +5471,8 @@ c.... First the flux in the x-direction
      .                          fy0 (ix,iy,0)*log(tg(ix ,iy ,igsp)) +
      .                          fyp (ix,iy,0)*log(tg(ix ,iy2,igsp)) + 
      .                          fymx(ix,iy,0)*log(tg(ix4,iy1,igsp)) +
-     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )*
-     .                                                      gxfn(ix,iy)
+     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )/ 
+     .                                                      dxnog(ix,iy)
                vygtan(ix,iy,igsp) = exp( 0.5*
      .                     (log(tg(ix2,iy,igsp))+log(tg(ix,iy,igsp))) )*
      .                      ( cngfx(igsp) / (mg(igsp)*0.5*(nu1+nu2)) ) *
@@ -5535,7 +5536,7 @@ c.... Now the flux in the y-direction
      .                              ( ngy0(ix,iy,igsp)*gy(ix,iy) + 
      .                                ngy1(ix,iy,igsp)*gy(ix,iy+1) ) / 
      .                                     (8*(gy(ix,iy)+gy(ix,iy+1)))
-             csh = (1-isgasdc) * cdifg(igsp) *sy(ix,iy) * gyf(ix,iy) *
+             csh = (1-isgasdc) * cdifg(igsp) *sy(ix,iy)/(dynog(ix,iy)) *
      .                                  ave(vtn**2/nu1, vtnp**2/nu2) +
      .            isgasdc * sy(ix,iy) * gyf(ix,iy) * difcng +
      .                      rld2dyg(igsp)**2*sy(ix,iy)*(1/gyf(ix,iy))*
@@ -5640,8 +5641,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                      fy0 (ix,iy,0)*log(ng(ix ,iy  ,igsp)) +
      .                      fyp (ix,iy,0)*log(ng(ix ,iy+1,igsp)) +
      .                      fymx(ix,iy,0)*log(ng(ix4,iy1 ,igsp)) + 
-     .                      fypx(ix,iy,0)*log(ng(ix6,iy+1,igsp)) ) )* 
-     .                                                  gxfn(ix,iy)
+     .                      fypx(ix,iy,0)*log(ng(ix6,iy+1,igsp)) ) )/ 
+     .                                                  dxnog(ix,iy)
                elseif (methgx .eq. 7) then  # inverse interpolation
                grdnv =( 1/(fym (ix,iy,1)/ng(ix2,iy1 ,igsp) + 
      .                     fy0 (ix,iy,1)/ng(ix2,iy  ,igsp) +
@@ -5652,8 +5653,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                     fy0 (ix,iy,0)/ng(ix ,iy  ,igsp) +
      .                     fyp (ix,iy,0)/ng(ix ,iy+1,igsp) +
      .                     fymx(ix,iy,0)/ng(ix4,iy1 ,igsp) + 
-     .                     fypx(ix,iy,0)/ng(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                     fypx(ix,iy,0)/ng(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                else                   # linear interpolation
                grdnv =( (fym (ix,iy,1)*ng(ix2,iy1 ,igsp) + 
      .                   fy0 (ix,iy,1)*ng(ix2,iy  ,igsp) +
@@ -5664,8 +5665,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                   fy0 (ix,iy,0)*ng(ix ,iy  ,igsp) +
      .                   fyp (ix,iy,0)*ng(ix ,iy+1,igsp) +
      .                   fymx(ix,iy,0)*ng(ix4,iy1 ,igsp) + 
-     .                   fypx(ix,iy,0)*ng(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                   fypx(ix,iy,0)*ng(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                endif
                difgx2 = ave( tg(ix ,iy,igsp)/nu1,
      .                       tg(ix2,iy,igsp)/nu2 )/mg(igsp)
@@ -5965,8 +5966,8 @@ c ..Timing;initialize
      .                          fy0 (ix,iy,0)*log(tg(ix ,iy ,igsp)) +
      .                          fyp (ix,iy,0)*log(tg(ix ,iy2,igsp)) + 
      .                          fymx(ix,iy,0)*log(tg(ix4,iy1,igsp)) +
-     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )*
-     .                                                      gxfn(ix,iy)
+     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )/ 
+     .                                                      dxnog(ix,iy)
                vygtan(ix,iy,igsp) = exp( 0.5*
      .                     (log(tg(ix2,iy,igsp))+log(tg(ix,iy,igsp))) )*
      .                      ( alftng / (mg(igsp)*0.5*(nu1+nu2)) ) *
@@ -6053,10 +6054,10 @@ c ..Timing; initiate time for y-direction calc
               qfl = flalfgy_adj * sy(ix,iy) * (vtn + vtnp)*rt8opi*
      .              (ngy0(ix,iy,igsp)+ngy1(ix,iy,igsp)) / 8.
             endif
-            csh = (1-isgasdc) * cdifg(igsp) *sy(ix,iy) * gyf(ix,iy) *
+            csh = (1-isgasdc) * (cdifg(igsp) *sy(ix,iy)/dynog(ix,iy)) *
      .                          (1/mg(igsp))* ave(1./nu1, 1./nu2) +
-     .            isgasdc * sy(ix,iy) * gyf(ix,iy) * difcng /tgf +
-     .                      rld2dyg(igsp)**2*sy(ix,iy)*(1/gyf(ix,iy))*
+     .            isgasdc * sy(ix,iy) * difcng /(dynog(ix,iy)*tgf) +
+     .                      rld2dyg(igsp)**2*sy(ix,iy)*dynog(ix,iy)*
      .                     0.5*(nuiz(ix,iy,igsp)+nuiz(ix,iy+1,igsp))/tgf
 
             qtgf = alftng * fgtdy(iy) * sy(ix,iy) * 
@@ -6175,8 +6176,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                      fy0 (ix,iy,0)*log(pg(ix ,iy  ,igsp)) +
      .                      fyp (ix,iy,0)*log(pg(ix ,iy+1,igsp)) +
      .                      fymx(ix,iy,0)*log(pg(ix4,iy1 ,igsp)) + 
-     .                      fypx(ix,iy,0)*log(pg(ix6,iy+1,igsp)) ) )*
-     .                                                  gxfn(ix,iy)
+     .                      fypx(ix,iy,0)*log(pg(ix6,iy+1,igsp)) ) )/ 
+     .                                                  dxnog(ix,iy)
                elseif (methgx .eq. 7) then # inverse interpolation
                grdnv =( 1/(fym (ix,iy,1)/pg(ix2,iy1 ,igsp) + 
      .                     fy0 (ix,iy,1)/pg(ix2,iy  ,igsp) +
@@ -6187,8 +6188,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                     fy0 (ix,iy,0)/pg(ix ,iy  ,igsp) +
      .                     fyp (ix,iy,0)/pg(ix ,iy+1,igsp) +
      .                     fymx(ix,iy,0)/pg(ix4,iy1 ,igsp) + 
-     .                     fypx(ix,iy,0)/pg(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                     fypx(ix,iy,0)/pg(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                else                   # linear interpolation
                grdnv =( (fym (ix,iy,1)*pg(ix2,iy1 ,igsp) + 
      .                   fy0 (ix,iy,1)*pg(ix2,iy  ,igsp) +
@@ -6199,8 +6200,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                   fy0 (ix,iy,0)*pg(ix ,iy  ,igsp) +
      .                   fyp (ix,iy,0)*pg(ix ,iy+1,igsp) +
      .                   fymx(ix,iy,0)*pg(ix4,iy1 ,igsp) + 
-     .                   fypx(ix,iy,0)*pg(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                   fypx(ix,iy,0)*pg(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                endif
                difgx2 = ave( 1./nu1,
      .                       1./nu2 )/mg(igsp)
@@ -6531,8 +6532,8 @@ c.... First the flux in the x-direction
      .                          fy0 (ix,iy,0)*log(tg(ix ,iy ,igsp)) +
      .                          fyp (ix,iy,0)*log(tg(ix ,iy2,igsp)) + 
      .                          fymx(ix,iy,0)*log(tg(ix4,iy1,igsp)) +
-     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )*
-     .                                                      gxfn(ix,iy)
+     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )/ 
+     .                                                      dxnog(ix,iy)
                vygtan(ix,iy,igsp) = exp( 0.5*
      .                     (log(tg(ix2,iy,igsp))+log(tg(ix,iy,igsp))) )*
      .                                  ( cngfx(igsp) / (mg(igsp)*0.5*
@@ -6587,11 +6588,11 @@ c.... Now the flux in the y-direction
             vtn = sqrt( t0/mg(igsp) )
             vtnp = sqrt( t1/mg(igsp) )
             qfl = flalfgya(iy,igsp) * sy(ix,iy) * (vtn + vtnp)*rt8opi/8
-            csh = (1-isgasdc) * cdifg(igsp) *sy(ix,iy) * gyf(ix,iy) *
+            csh = (1-isgasdc) * (cdifg(igsp) *sy(ix,iy)/dynog(ix,iy)) *
      .                            ave( vtn**2/nuix(ix,iy,igsp) ,
      .                                 vtnp**2/nuix(ix,iy+1,igsp) ) +
-     .            isgasdc * sy(ix,iy) * gyf(ix,iy) * difcng +
-     .                      rld2dyg(igsp)**2*sy(ix,iy)*(1/gyf(ix,iy))*
+     .            isgasdc * sy(ix,iy) * difcng / dynog(ix,iy) +
+     .                      rld2dyg(igsp)**2*sy(ix,iy)*dynog(ix,iy)*
      .                       0.5*(nuiz(ix,iy,igsp)+nuiz(ix,iy+1,igsp))
 c               csh = sy(ix,iy) * gyf(ix,iy) * ( (vtn**2+vtnp**2)/
 c     .                 (nuix(ix,iy,igsp)+nuix(ix,iy+1,igsp)) )
@@ -6691,8 +6692,8 @@ ccc            MER: Set flag to apply xy flux limit except at target plates
      .                   fy0 (ix,iy,0)*lng(ix ,iy  ,igsp) +
      .                   fyp (ix,iy,0)*lng(ix ,iy+1,igsp) +
      .                   fymx(ix,iy,0)*lng(ix4,iy1 ,igsp) + 
-     .                   fypx(ix,iy,0)*lng(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                   fypx(ix,iy,0)*lng(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
 
                difgx2 = ave( tg(ix ,iy,igsp)/nuix(ix ,iy,igsp),
      .                       tg(ix2,iy,igsp)/nuix(ix2,iy,igsp) )/mg(igsp)
@@ -6931,7 +6932,7 @@ c     .                 (nuix(ix,iy,igsp)+nuix(ix2,iy,igsp))
      .                     fy0 (ix,iy,0)*tg(ix ,iy ,igsp) -
      .                     fyp (ix,iy,0)*tg(ix ,iy2,igsp) - 
      .                     fymx(ix,iy,0)*tg(ix4,iy1,igsp) -
-     .                     fypx(ix,iy,0)*tg(ix6,iy2,igsp) )*gxfn(ix,iy)
+     .                     fypx(ix,iy,0)*tg(ix6,iy2,igsp) )/dxnog(ix,iy)
                elseif (isintlog .eq. 1) then
                   grdnv =( exp( fym (ix,iy,1)*log(tg(ix2,iy1,igsp)) +
      .                          fy0 (ix,iy,1)*log(tg(ix2,iy ,igsp)) +
@@ -6942,8 +6943,8 @@ c     .                 (nuix(ix,iy,igsp)+nuix(ix2,iy,igsp))
      .                          fy0 (ix,iy,0)*log(tg(ix ,iy ,igsp)) +
      .                          fyp (ix,iy,0)*log(tg(ix ,iy2,igsp)) + 
      .                          fymx(ix,iy,0)*log(tg(ix4,iy1,igsp)) +
-     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )*
-     .                                                      gxfn(ix,iy)
+     .                          fypx(ix,iy,0)*log(tg(ix6,iy2,igsp)) ) )/ 
+     .                                                      dxnog(ix,iy)
                endif
                vygtan(ix,iy,igsp) = ( cngfx(igsp) / (mg(igsp)*0.5*
      .                         (nuix(ix,iy,igsp)+nuix(ix2,iy,igsp))) ) *
@@ -7002,13 +7003,13 @@ c.... Now the flux in the y-direction
      .                              ( ngy0(ix,iy,igsp)*gy(ix,iy) + 
      .                                ngy1(ix,iy,igsp)*gy(ix,iy+1) ) / 
      .                                     (8*(gy(ix,iy)+gy(ix,iy+1)))
-            csh = (1-isgasdc) * cdifg(igsp) *sy(ix,iy) * gyf(ix,iy) *
+            csh = (1-isgasdc) * (cdifg(igsp) *sy(ix,iy) /dynog(ix,iy)) *
      .                            ave( vtn**2/nuix(ix,iy,igsp) ,
      .                                 vtnp**2/nuix(ix,iy+1,igsp) ) +
-     .            isgasdc * sy(ix,iy) * gyf(ix,iy) * difcng +
-     .                      rld2dyg(igsp)**2*sy(ix,iy)*(1/gyf(ix,iy))*
+     .            isgasdc * sy(ix,iy) * difcng / dynog(ix,iy) +
+     .                      rld2dyg(igsp)**2*sy(ix,iy)*dynog(ix,iy)*
      .                       0.5*(nuiz(ix,iy,igsp)+nuiz(ix,iy+1,igsp))
-c               csh = sy(ix,iy) * gyf(ix,iy) * ( (vtn**2+vtnp**2)/
+c               csh = sy(ix,iy) * ( ((vtn**2+vtnp**2)/ dynog(ix,iy)) /
 c     .                 (nuix(ix,iy,igsp)+nuix(ix,iy+1,igsp)) )
             qtgf = cngfy(igsp) * fgtdy(iy) * sy(ix,iy) * 
      .                     ave( gy(ix,iy)/nuix(ix,iy,igsp) ,
@@ -7134,8 +7135,8 @@ c...  Addition for nonorthogonal mesh
      .                      fy0 (ix,iy,0)*log(ng(ix ,iy  ,igsp)) +
      .                      fyp (ix,iy,0)*log(ng(ix ,iy+1,igsp)) +
      .                      fymx(ix,iy,0)*log(ng(ix4,iy1 ,igsp)) + 
-     .                      fypx(ix,iy,0)*log(ng(ix6,iy+1,igsp))) ) *
-     .                                                  gxfn(ix,iy)
+     .                      fypx(ix,iy,0)*log(ng(ix6,iy+1,igsp))) ) / 
+     .                                                  dxnog(ix,iy)
                elseif (methgx .eq. 7) then  # inverse interpolation
                grdnv =( 1/(fym (ix,iy,1)/ng(ix2,iy1 ,igsp) + 
      .                     fy0 (ix,iy,1)/ng(ix2,iy  ,igsp) +
@@ -7146,8 +7147,8 @@ c...  Addition for nonorthogonal mesh
      .                     fy0 (ix,iy,0)/ng(ix ,iy  ,igsp) +
      .                     fyp (ix,iy,0)/ng(ix ,iy+1,igsp) +
      .                     fymx(ix,iy,0)/ng(ix4,iy1 ,igsp) + 
-     .                     fypx(ix,iy,0)/ng(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                     fypx(ix,iy,0)/ng(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                else                   # linear interpolation
                grdnv =( (fym (ix,iy,1)*ng(ix2,iy1 ,igsp) + 
      .                   fy0 (ix,iy,1)*ng(ix2,iy  ,igsp) +
@@ -7158,8 +7159,8 @@ c...  Addition for nonorthogonal mesh
      .                   fy0 (ix,iy,0)*ng(ix ,iy  ,igsp) +
      .                   fyp (ix,iy,0)*ng(ix ,iy+1,igsp) +
      .                   fymx(ix,iy,0)*ng(ix4,iy1 ,igsp) + 
-     .                   fypx(ix,iy,0)*ng(ix6,iy+1,igsp)) ) *
-     .                                                  gxfn(ix,iy)
+     .                   fypx(ix,iy,0)*ng(ix6,iy+1,igsp)) ) / 
+     .                                                  dxnog(ix,iy)
                endif
                difgx2 = ave( tg(ix ,iy,igsp)/nuix(ix ,iy,igsp),
      .                       tg(ix2,iy,igsp)/nuix(ix2,iy,igsp) )/mg(igsp)
@@ -7372,7 +7373,7 @@ c... flux-limit occurs in building hcxg - do not flux-limit 2nd time
       do igsp = 1, ngsp
         do iy = j1, j5
           do ix = i4, i8
-            conyge(ix,iy,igsp) = sy(ix,iy)*hcyg(ix,iy,igsp)*gyf(ix,iy)
+            conyge(ix,iy,igsp) = sy(ix,iy)*hcyg(ix,iy,igsp)/dynog(ix,iy)
           enddo
         enddo
       enddo
@@ -11904,7 +11905,6 @@ c ... Output arguments:
        real tick,tock
        external tick tock
        TimeJac=tick()
-	    
       if (ParallelJac.eq.1) then
       call jac_calc_parallel (neq, t, yl, yldot00, ml, mu, wk,
      .               nnzmx, jac, ja, ia)
diff --git a/com/com.v b/com/com.v
index 56f6a74..c73b014 100644
--- a/com/com.v
+++ b/com/com.v
@@ -361,8 +361,10 @@ gy(0:nx+1,0:ny+1)   _real   [m^-1]  #1/(y-diameter) of the (ix,iy) primary cell
 dx(0:nx+1,0:ny+1)   _real   [m]     # x-distance of (ix,iy) primary cell;=1/gx
 dxvf(0:nx+1,0:ny+1) _real   [m]     # x-distance of between vel cell ctrs
 dy(0:nx+1,0:ny+1)   _real   [m]     # y-distance of (ix,iy) primary cell;=1/gy
+dynog(0:nx+1,0:ny+1) _real  [m]     #sep btwn nonog interp pts normal to y-face
 gxf(0:nx+1,0:ny+1)  _real   [m^-1]  #1/(x-distance) between density centers
-gxfn(0:nx+1,0:ny+1) _real   [m^-1]  #1/dist. btwn interp. pts, normal to x-face
+##gxfn(0:nx+1,0:ny+1) _real   [m^-1]  #1/dist. btwn interp. pts, normal to x-face
+dxnog(0:nx+1,0:ny+1) _real  [m]     #sep btwn nonog interp pts normal to x-face
 gyf(0:nx+1,0:ny+1)  _real   [m^-1]  #1/(y-distance) perp to y-face between
                                     #niy0 and niy1 variables, etc.
 gxc(0:nx+1,0:ny+1)  _real   [m^-1]  #1/(x-distance) between density vertices
